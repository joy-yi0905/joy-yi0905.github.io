<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端技术空间</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yi-jy.com/"/>
  <updated>2018-09-04T14:52:50.000Z</updated>
  <id>http://yi-jy.com/</id>
  
  <author>
    <name>易建勇,YI_joy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node环境变量设置</title>
    <link href="http://yi-jy.com/2018/08/08/node-env/"/>
    <id>http://yi-jy.com/2018/08/08/node-env/</id>
    <published>2018-08-08T14:29:11.000Z</published>
    <updated>2018-09-04T14:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况下，我们需要针对不同环境（开发环境、集成环境、生产环境等），进行相应策略的打包（比如是否替换接口地址，代码是否压缩等）。</p><p>拿 Nodejs 打包工具来说，由于 Nodejs 打包工具运行在 Nodejs 环境中，要识别不同环境，就得配置 Nodejs 环境变量，并且把它当成判断不同环境的依据。</p><a id="more"></a><p>Nodejs 提供了 <code>process.env</code> API，它返回一个包含用户环境信息的对象。当我们给 Nodejs 设置一个环境变量，并且把它挂载在 <code>process.env</code> 返回的对象上，便可以在代码中进行相应的环境判断。</p><p>于是，在Webpack配置文件中，经常会看到类似的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'production'</span> : <span class="string">'development'</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要说明的是，<code>NODE_ENV</code> 这个名称只是开发社区的一种共识，名称内容是可以修改的。如果需要，你也可以把它定义为 <code>NODE_XXX</code>。</p><p>那么问题来了，如何设置 Nodejs 这个环境变量呢？总结下来，可通过以下几种方式。</p><h2 id="在Webpack配置文件直接赋值"><a href="#在Webpack配置文件直接赋值" class="headerlink" title="在Webpack配置文件直接赋值"></a>在Webpack配置文件直接赋值</h2><p>这种方式比较简单粗暴。你只需要在 Webpack 打包配置文件中，直接给 <code>process.env.NODE_ENV</code> 赋值即可。不过，每次在不同环境下打包时，都要手动反复修改它的值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line">process.env.NODE_ENV = <span class="string">'production'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'production'</span> : <span class="string">'development'</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令行（CLI）设置"><a href="#命令行（CLI）设置" class="headerlink" title="命令行（CLI）设置"></a>命令行（CLI）设置</h2><h3 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h3><p>Windows 系统下，最常用的命令行面板就是 <code>CMD</code>（Command的简写） 和 <code>Powershell</code>。它们的操作分别如下：</p><h4 id="CMD-Command-或-命令提示符"><a href="#CMD-Command-或-命令提示符" class="headerlink" title="CMD (Command 或 命令提示符)"></a>CMD (Command 或 命令提示符)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有环境变量</span></span><br><span class="line">set</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line">set NODE_ENV</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line">set NODE_ENV=production</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line">set NODE_ENV=</span><br></pre></td></tr></table></figure><p>上面的命令行以 <code>NODE_ENV</code> 变量为例，在 CMD 命令面板的操作中，如果 <code>NODE_ENV</code> 没有设置，则通过 <code>set NODE_ENV</code> 命令查看时，会提示 <code>环境变量 NODE_ENV 没有定义</code>。</p><p>当设置完 <code>NODE_ENV</code>（假设设置值为 <code>production</code>），再通过 <code>set NODE_ENV</code> 命令查看时，会返回 <code>NODE_ENV=production</code>。</p><h4 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有环境变量</span></span><br><span class="line">ls env:</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line"><span class="meta">$</span><span class="bash">env:NODE_ENV</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line"><span class="meta">$</span><span class="bash">env:NODE_ENV=<span class="string">"production"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line">del env:NODE_ENV</span><br></pre></td></tr></table></figure><p>上面的命令行以 <code>NODE_ENV</code> 变量为例，在 Powershell 命令面板的操作中，若 <code>NODE_ENV</code> 没有设置，则通过 <code>set NODE_ENV</code> 命令查看它时，没有任何提示。</p><p>当设置完 <code>NODE_ENV</code>（假设设置值为 <code>production</code>），再通过 <code>set NODE_ENV</code> 命令查看它时，会返回 <code>production</code>。</p><p><strong>注意点</strong></p><p>上面的环境设置只是临时的，即只针对当前运行窗口的环境有效。当CLI运行窗口关闭以后，相关设置都会丢失。</p><p>另外，虽然通过 CMD 和 Powershell 都能修改环境变量，但它们之间设置的环境变量并不会相互影响，即你在 CMD 可以设置 <code>NODE_ENV</code> 为 <code>production</code>，同时也可以在 Powershell 中设置 <code>NODE_ENV</code> 为 <code>development</code>，这也印证了上面的描述，设置只针对当前运行窗口有效 。</p><p>如果你希望设置一直生效（即 本地设置），可通过 <code>控制面板 -&gt; 系统和安全 -&gt; 系统 -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量</code> 这样进行设置（Windows10、可能需要重启）。</p><h3 id="Mac-系统"><a href="#Mac-系统" class="headerlink" title="Mac 系统"></a>Mac 系统</h3><p>相当于 Windows 系统，Mac 系统上的操作就轻松了不少。因为它只集成一种命令行终端，它设置 Nodejs 环境变量的语法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有环境变量</span></span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line">echo $NODE_ENV</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line">export NODE_ENV=production</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line">unset NODE_ENV</span><br></pre></td></tr></table></figure><p>在配置完 Nodejs 环境变量后，你就可以继续运行项目中的打包命令了。</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>Git(Bash)是一款跨平台的命令行终端，我们也可以用它来设置 Nodejs 环境变量，语法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有环境变量</span></span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line">echo $NODE_ENV</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line">export NODE_ENV=production</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除单个环境变量（以 NODE_ENV 为例）</span></span><br><span class="line">unset NODE_ENV</span><br></pre></td></tr></table></figure><p>上面的命令行以 <code>NODE_ENV</code> 变量为例，在 Git 命令行操作中，若 <code>NODE_ENV</code> 没有设置，则通过 <code>echo $NODE_ENV</code> 命令查看它时，没有任何提示。</p><p>当设置完 <code>NODE_ENV</code>（假设设置值为 <code>production</code>），再通过 <code>set NODE_ENV</code> 命令查看它时，会返回 <code>production</code>。</p><p><em>需要说明的是，在 Mac 系统下，Git安装后，是集成在系统自带的命令行终端中。</em></p><p>但是，采用 命令行（CLI）设置 的方式来修改 Nodejs 环境变量有一个不好地方。即每次在运行打包命令前，都要先通过 <code>set NODE_ENV=xx</code> 或者 <code>export NODE_ENV=xx</code> 等类似的命令来设置或者切换环境变量（这里指的是重开了命令窗口，或者切换打包环境的情况下），是否觉得这样麻烦？</p><p>幸好，我们还有第二种做法，即 配置 package.json。</p><h2 id="配置-package-json"><a href="#配置-package-json" class="headerlink" title="配置 package.json"></a>配置 package.json</h2><p>在项目配置文件 package.json 中，根据不同的打包命令去设置相应的 Nodejs 环境变量，是一种非常主流的做法。其实本质上来说，只是将在命令行面板设置环境变量的命令语句放到了 <code>package.json</code> 文件中，把 设置环境变量 和 打包 两个命令合并运行而已。</p><p>这种方式，就是将 <code>NODE_ENV</code> 注入到 <code>process.env</code> 对象。不同环境下，设置如下：</p><h3 id="Windows-系统-1"><a href="#Windows-系统-1" class="headerlink" title="Windows 系统"></a>Windows 系统</h3><p>在这种方式下，无论你是使用 CMD (命令提示符) 还是 Powershell 命令行工具，你都可以在 <code>package.json</code> 这样配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"set NODE_ENV=production&amp;&amp; npm run clean &amp;&amp; webpack"</span>,</span><br><span class="line">    <span class="string">"clean"</span>: <span class="string">"rimraf ./build &amp;&amp; mkdirp build"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完后（<code>mkdirp</code> 是一个生成文件夹的第三方包），你只需要在命令行面板运行 <code>npm run build</code> 即可完成打包。</p><p><strong>注意点</strong></p><p>在 Windows 系统中，你必须移除环境变量命令与 <code>&amp;&amp;</code> 符号之间的空白。否者，配置的命令不能生效！</p><h3 id="Mac-系统-1"><a href="#Mac-系统-1" class="headerlink" title="Mac 系统"></a>Mac 系统</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"export NODE_ENV=production &amp;&amp; npm run clean &amp;&amp; webpack"</span>,</span><br><span class="line">    <span class="string">"clean"</span>: <span class="string">"rimraf ./build &amp;&amp; mkdirp build"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面描述可以看到，不论是不同的操作系统，还是不同的命令行终端，虽然目的都是设置 Nodejs 环境变量，但它们的语法都不尽相同。这就带来两个问题：</p><ul><li>在 Windows 开发部署的项目，可能在 Mac 系统无法正常打包</li><li>在跨平台开发的项目上，你还得记住每个命令行终端所使用的语法，也麻烦</li></ul><p>为了解决这一问题，有人开发了 <code>cross-env</code>。</p><h3 id="跨平台-cross-env"><a href="#跨平台-cross-env" class="headerlink" title="跨平台 - cross-env"></a>跨平台 - cross-env</h3><p><a href="https://www.npmjs.com/package/cross-env" target="_blank" rel="noopener">cross-env</a> 是一个跨平台设置环境变量的第三方包，它可以让你只配置一行命令，就能轻松地在多个平台设置环境变量。</p><p>首先，你只需要安装它（由于多个项目在用，所以就全局安装了）：</p><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">npm install -g <span class="keyword">cross</span>-<span class="keyword">env</span></span><br></pre></td></tr></table></figure><p>然后，在 <code>package.json</code> 文件中进行设置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"npm run clean &amp;&amp; cross-env NODE_ENV=production webpack"</span>,</span><br><span class="line">    <span class="string">"clean"</span>: <span class="string">"rimraf ./build &amp;&amp; mkdirp build"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不管你的电脑是 Windows 系统还是 Mac 系统 ，不管你用的 Powershell 还是 Git，你都可以正常设置 Nodejs 环境变量了。</p><p>注意，<code>cross-env NODE_ENV=production &amp;&amp; npm run clean &amp;&amp; webpack</code> 此类的设置不能使环境变量生效。原因是 <code>&amp;&amp;</code> 符号把命令语句分离成了多个，每一个命令执行的环境都是隔离的，而 <code>cross-env</code> 无法作用于其他环境的命令。</p>]]></content>
    
    <summary type="html">
    
      Node环境变量设置
    
    </summary>
    
    
      <category term="Nodejs" scheme="http://yi-jy.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>webpack分离第三方库及公用文件</title>
    <link href="http://yi-jy.com/2018/06/09/webpack-split-chunks/"/>
    <id>http://yi-jy.com/2018/06/09/webpack-split-chunks/</id>
    <published>2018-06-09T07:42:42.000Z</published>
    <updated>2018-07-22T15:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们开发的项目中，具体代码文件主要包含三种类型，有 第三方库、工具函数、业务代码。在这篇文章，你会看到使用 webpack 处理这些文件的一些方法。</p><a id="more"></a><p>为了便于说明，首先，安装需要用到的第三方库，这里，以 <code>jQuery</code> 为例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -S jquery</span><br></pre></td></tr></table></figure><h2 id="一、直接引入"><a href="#一、直接引入" class="headerlink" title="一、直接引入"></a>一、直接引入</h2><p>我们最常用的引入方式，就是用 AMD 或者 ES6 模块导入的形式在具体的业务模块中直接引入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>; <span class="comment">// 或者 const $ = require('jquery');</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'h1'</span>).hide();</span><br></pre></td></tr></table></figure><p>如果webpack配置文件没有做其他相关设置，那么在这种情况下，jQuery 源码会和业务代码最终会打包到一个文件中。</p><p>倘若多个业务模块都引用了 jQuery，则在打包时，webpack很机智，不会对 jQuery 源码进行多次打包。即最终打包的文件，只包含一份 jQuery 源码。</p><h2 id="二、webpack-ProvidePlugin"><a href="#二、webpack-ProvidePlugin" class="headerlink" title="二、webpack.ProvidePlugin"></a>二、webpack.ProvidePlugin</h2><p>如果想要使用 jQuery，但又不想在业务代码中反复使用 <code>import $ from &#39;jquery&#39;</code> 来引入 jQuery，你可以使用 <code>ProvidePlugin</code> 。它属于webpack的内置API，我们可以在 webpack 配置文件进行如下设置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">      $: <span class="string">'jquery'</span>,</span><br><span class="line">      jQuery: <span class="string">'jquery'</span></span><br><span class="line">    &#125;)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们甚至不用通过 <code>require(&#39;jquery&#39;)</code> 或者 <code>import $ from &#39;jquery&#39;</code> 这种形式引入 jQuery，就能在开发模块中使用 jQuery 的 API 了，如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.js</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'h1'</span>).hide(); <span class="comment">// 或者 jQuery('h1').hide();</span></span><br></pre></td></tr></table></figure><p>在使用 <code>webpack-dev-server</code> 插件启动本地服务开发的环境下，应用上面的设置，会把 jQuery 源码和其他模块一起打包成一个文件，假设打包后的文件为 <code>main.js</code>，当打开 <code>main.js</code>，你会发现，jQuery 的源码处于 <code>main.js</code> 的顶部，有关 jQuery 操作的代码，则是在后面的一个独立模块。</p><p>当打包发布生产环境时，<code>jQuery</code> 源码也会和其他模块一起打包成一个文件，也是位于文件的顶部，不同的是，有关 jQuery 操作的代码，是和 jQuery 源码处于同一模块。</p><p>由于在开发环境和生产环境，jQuery 都是以模块的形式呈现，因此，你在浏览器的控制台，无法使用 jQuery 的API。即只能是在开发模块中，使用在 <code>ProvidePlugin</code> 中定义好的 <code>$</code> 或者 <code>jQuery</code>。</p><p>如果要使用 <code>jQuery</code> 的第三方插件，也是非常方便的，比如绘制圆环的插件，安装npm包后，直接引入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'jquery-circle-progress'</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#circle'</span>).circleProgress(&#123;</span><br><span class="line">  value: <span class="number">0.75</span>,</span><br><span class="line">  size: <span class="number">80</span>,</span><br><span class="line">  fill: &#123;</span><br><span class="line">    gradient: [<span class="string">"red"</span>, <span class="string">"orange"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="三、expose-loader"><a href="#三、expose-loader" class="headerlink" title="三、expose-loader"></a>三、expose-loader</h2><p>通过前面的方式，我们知道，打包后 jQuery 源码以模块的形式呈现。因此，对于一些依赖它的文件，或者希望在Chrome开发者工具中，调试 jQuery API等情况并不友好。</p><p>针对这个问题，我们放弃使用 <code>webpack.ProvidePlugin</code> 方案（移除配置中的相关代码）。而是采用另外一种方案 - <code>expose-loader</code>。它的功能主要是将第三方库（本文指的是 jQuery）暴露给全局变量环境中，这样一来，无论是调试页面，还是依赖它的其他js文件，都能很方便的使用到它的API。</p><p>首先，我们安装它：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i expose-loader -D</span><br></pre></td></tr></table></figure><p>然后，我们对 webpack 配置文件进行如下更新（前提是你已安装 jQuery）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="built_in">require</span>.resolve(<span class="string">'jquery'</span>),</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">'expose-loader'</span>,</span><br><span class="line">          options: <span class="string">'$'</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，需要在业务代码中引入第三方库，才能将它暴露到全局变量中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>; <span class="comment">// 或者 require('jquery');</span></span><br></pre></td></tr></table></figure><p>倘若你希望对这个第三方库设置多个全局变量，则可以继续新增：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="built_in">require</span>.resolve(<span class="string">'jquery'</span>),</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">'expose-loader'</span>,</span><br><span class="line">          options: <span class="string">'$'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">'expose-loader'</span>,</span><br><span class="line">          options: <span class="string">'jQuery'</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，除了原来的 <code>$</code>，现在还增加了 <code>jQuery</code> 作为 jQuery 的全局变量。如此一来，在 Chrome 开发者工具控制台中，无论是使用变量 <code>$</code> 还是使用 <code>jQuery</code>，它们都能正常访问 jQuery 的 API。</p><p>如果项目中希望对其他第三方库（比如 lodash、react 等）暴露全局变量，那你只需要在安装好这些第三方库后，再在打包配置文件中，做相关新增类似配置即可。</p><p>可以看到，虽然在采用了 <code>webpack.ProvidePlugin</code> 方案后，模块无需在业务代码中引入第三方库，就能使用相关 API，但它无法全局，对依赖包不友好。而 <code>expose-loader</code> 则需要在业务代码中引入第三方库 ，它解决 <code>webpack.ProvidePlugin</code> 存在的问题。</p><h2 id="四、externals"><a href="#四、externals" class="headerlink" title="四、externals"></a>四、externals</h2><p>说到这里，其实对于上面的两种方案，我们都忽略一个重要的问题。</p><p>按理来说，对于第三方库而言，我们几乎不会修改它的源码。因此，并非每次修改完业务代码，都需要每次都将第三方库也重新打包一遍。</p><p>而上述的 <code>webpack.ProvidePlugin</code> 和 <code>expose-loader</code> 方案，都存在第三方库重新打包或者说需要打包的问题，这就直接导致了打包效率慢。同时，这也导致了第三方库和业务代码打包在了一起，所以，打包后的文件通常都比较大。</p><p>而对于这两个问题，我们可以通过配置 <code>externals</code> 选项来解决。</p><p>首先，在webpack配置文件进行相关设置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  externals: &#123;</span><br><span class="line">    jquery: <span class="string">'$'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，针对第三方库，我们一般用相对路径或者类似 CDN 这种绝对路径的形式，以 <code>&lt;script&gt;</code> 标签在页面里直接引入。这里我们拿 CDN 上的 jQuery 做演示：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.1.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，无需在业务代码中引入第三方库，就能直接使用 jQuery 的 API：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.js</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'h1'</span>).hide();</span><br></pre></td></tr></table></figure><p>再次打包，你会发现打包效率变高了，因为第三方库不参与打包。你会发现打包后的文件变小了，因为第三方库与业务代码分离了。你会发现 jQuery 被暴露为全局变量，因为第三方库引用的是 CDN，而非webpack模块。另外，即使你没在业务代码中引入第三方库，你也在这个业务模块使用 jQuery 的 API。</p><p>但如果你不在 <code>index.html</code> 页面中 jQuery 文件（即移除上面的 <code>script</code> 连接），而是采用在业务代码中引入它（即 <code>import $ from &#39;jquery&#39;</code>），则会直接导致报错。毕竟这也违背了 <code>externals</code> 分离第三方库的初衷。</p><p>可以说，<code>externals</code> 方案满足了我们大多数功能！</p><h2 id="五、将第三方库从业务文件分离-Entry-CommonsChunkPlugin"><a href="#五、将第三方库从业务文件分离-Entry-CommonsChunkPlugin" class="headerlink" title="五、将第三方库从业务文件分离 - Entry + CommonsChunkPlugin"></a>五、将第三方库从业务文件分离 - Entry + CommonsChunkPlugin</h2><p>前面说到，由于第三方库几乎不怎么会变动，所以，我们通常希望这样处理它：</p><ul><li>打包时，不对第三方库进行打包（加快打包速度）</li><li>将第三方库与业务代码分离，让第三方库充分利用浏览器缓存</li></ul><h3 id="5-1-最初打包"><a href="#5-1-最初打包" class="headerlink" title="5.1 最初打包"></a>5.1 最初打包</h3><p>为方便说明，我们首先安装了两个工具库，分别是 jQuery 和 lodash：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -S jquery lodash</span><br></pre></td></tr></table></figure><p>假设有公共函数模块：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dataType</span>(<span class="params">argument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(argument).replace(<span class="regexp">/\[object\s/</span>, <span class="string">''</span>).replace(<span class="regexp">/\]/</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再假设有以下两个业务js文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app1.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> utils <span class="keyword">from</span> <span class="string">'./utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'app1'</span>, _.chunk([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], <span class="number">1</span>)); <span class="comment">// ['a'] ['b'] ['c'] ['d']</span></span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'.app1'</span>).css(<span class="string">'color'</span>, <span class="string">'red'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'app1'</span>, utils.dataType([])); <span class="comment">// Array</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app2.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> utils <span class="keyword">from</span> <span class="string">'./utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'app2'</span>, _.chunk([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], <span class="number">2</span>)); <span class="comment">// ['a', 'b'] ['c', 'd']</span></span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'.app2'</span>).css(<span class="string">'color'</span>, <span class="string">'blue'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'app2'</span>, utils.dataType(&#123;&#125;)); <span class="comment">// Object</span></span><br></pre></td></tr></table></figure><p>让我们调整下配置文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app1: <span class="string">'./src/app1.js'</span>,</span><br><span class="line">    app2: <span class="string">'./src/app2.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，打包后生成了 <code>app1.min.js</code> 和 <code>app2.min.js</code> 两个文件，页面也正常引用了这两个js文件，功能也都正常。</p><p>但是，当打开 <code>app1.min.js</code> 和 <code>app2.min.js</code>，你会发现，这两个文件都包含了 jQuery、lodash 以及 utils.js 的源码，也就是说，webpack对于不同业务模块引用的公用文件（工具库）会重复打包，这显然是不对的。我们希望的理想情况是，所有的公用文件，只打包一次，在页面里也只引入一次。</p><p>那我们就要使用到 <code>Entry + CommonsChunkPlugin</code>。</p><h3 id="5-2-公用资源的分离"><a href="#5-2-公用资源的分离" class="headerlink" title="5.2 公用资源的分离"></a>5.2 公用资源的分离</h3><p>再次调整配置文件，在入口文件中新增第三方库的配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> packagejson = <span class="built_in">require</span>(<span class="string">'./package.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: <span class="built_in">Object</span>.keys(packagejson.dependencies), <span class="comment">// 或者 vendor: ['jquery', 'lodash']</span></span><br><span class="line">    app1: path.resolve(__dirname, <span class="string">'./src/app1.js'</span>),</span><br><span class="line">    app2: path.resolve(__dirname, <span class="string">'./src/app2.js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: [<span class="string">'vendor'</span>],</span><br><span class="line">      filename: <span class="string">'[name].js'</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次打包，生成了 <code>vendor.js</code>、<code>app1.min.js</code> 、<code>app2.min.js</code> 这三个文件。此时，再打开 <code>app1.min.js</code> 、<code>app2.min.js</code>，会发现里面只包含我们自己写的业务代码，而 jQuery、lodash 以及 utils.js 的源码则被打进了 <code>vendor.js</code> 这个文件中。</p><p>使用这种方式打包，除了可以分离公用资源、避免重复打包以外。对第三方库（这里指的是 jQuery、lodash），在业务代码中还可以无需引入模块，便能使用第三方库的API。比如，<code>app1.js</code> 可以调整为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app1.js  无需在此文件中引入 jquery 和 lodash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> utils <span class="keyword">from</span> <span class="string">'./utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'app2'</span>, _.chunk([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], <span class="number">2</span>)); <span class="comment">// ['a', 'b'] ['c', 'd']</span></span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'.app2'</span>).css(<span class="string">'color'</span>, <span class="string">'blue'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'app2'</span>, utils.dataType(&#123;&#125;)); <span class="comment">// Object</span></span><br></pre></td></tr></table></figure><h3 id="5-3-第三方库、工具函数模块，业务代码的分离"><a href="#5-3-第三方库、工具函数模块，业务代码的分离" class="headerlink" title="5.3 第三方库、工具函数模块，业务代码的分离"></a>5.3 第三方库、工具函数模块，业务代码的分离</h3><p>到这里为止，我们基本达到了公用资源与业务代码分离的需求。但是，由于公用资源又包含 第三方库 和 工具函数模块。可以肯定的是，第三方库我们几乎不改，但 工具函数模块 则可能会不定时的修改。因此，最理想的情况是，把 第三方模块 和 工具函数模块 也分离开来。</p><p>这个也好办，只需要利用 <code>chunks</code> 再指定引用了 工具函数模块 的js文件即可。再次调整配置文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'common'</span>,</span><br><span class="line">      filename: <span class="string">'[name].[chunkhash].js'</span>,</span><br><span class="line">      chunks: [<span class="string">'app1'</span>, <span class="string">'app2'</span>]</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: [<span class="string">'vendor'</span>],</span><br><span class="line">      filename: <span class="string">'[name].js'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次打包，则生成了 <code>vendor.js</code>、<code>common.js</code>、<code>app1.min.js</code> 、<code>app2.min.js</code> 这四个文件。它们的内容分别如下：</p><ul><li><code>vendor.js</code>: 第三方库代码（这里指 jQuery + lodash）</li><li><code>common.js</code>: 工具函数模块</li><li><code>app1.min.js</code>: 业务代码1</li><li><code>app2.min.js</code>: 业务代码2</li></ul><p>这样，便达到我们最终的目的。打开这四个文件，你会发现，后面三个都是以 <code>webpackJsonp([0], ...)</code>、<code>webpackJsonp([1], ...)</code>  … 这样开头的webpack运行模块。</p><p>并且，由于我们是将第三方库单独打包在一个文件里，因此，你可以在该文件后面或者浏览器控制台使用第三方库的API。</p><p><strong>不过注意，在 webpack4.x 中，<code>CommonsChunkPlugin</code> 这种形式已经被废弃了。</strong></p><p>当你尝试在 webpack4.x 中使用 <code>CommonsChunkPlugin</code>，在命令面板会出现报错，并提示我们用 <code>optimization.splitChunks</code>：</p><img src="/2018/06/09/webpack-split-chunks/CommonsChunkPlugin-error.png" title="CommonsChunkPlugin错误"><h2 id="六、webpack4-x-模块分离-optimization-splitChunks"><a href="#六、webpack4-x-模块分离-optimization-splitChunks" class="headerlink" title="六、webpack4.x 模块分离 - optimization + splitChunks"></a>六、webpack4.x 模块分离 - optimization + splitChunks</h2><p>在 webpack4.x 中，我们使用 <code>optimization.splitChunks</code> 来分离公用的代码块。</p><p>这里说的分离，当然只是针对一些第三方库（一般来自 node_modules），以及我们自己定义的工具库（或公用方法）。不然，还分离啥呢？</p><p>不知如何下手？首先，我们来看官网给的一份默认配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: <span class="string">'async'</span>,</span><br><span class="line">    minSize: <span class="number">30000</span>,</span><br><span class="line">    maxSize: <span class="number">0</span>,</span><br><span class="line">    minChunks: <span class="number">1</span>,</span><br><span class="line">    maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">    maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">    automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">    name: <span class="literal">true</span>,</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      vendors: &#123;</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        priority: <span class="number">-10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        minChunks: <span class="number">2</span>,</span><br><span class="line">        priority: <span class="number">-20</span>,</span><br><span class="line">        reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们再来看下它们的含义：</p><ul><li><strong>chunks：</strong> 该属性值的数据类型可以是 字符串 或者 函数。如果是字符串，那它的值可能为 initial | async | all 三者之一。默认值的数据类型为 字符串，默认值为 async，但推荐用 all。它表示将哪种类型的模块分离成新文件。字符串参数值的作用分别如下：<ul><li>initial：表示对异步引入的模块不处理</li><li>async：表示只处理异步模块</li><li>all：无论同步还是异步，都会处理</li></ul></li><li><strong>minSize：</strong> 该属性值的数据类型为数字。它表示将引用模块分离成新代码文件的最小体积，默认为 <code>30000</code>，单位为字节，即 30K（指min+gzip之前的体积）。这里的 30K 应该是最佳实践，因为如果引用模块小于 30K 就分离成一个新代码文件，那页面打开时，势必会多增加一个请求。</li><li><strong>maxSize：</strong> 该属性值的数据类型为数字。它表示？</li><li><strong>minChunks：</strong> 该属性值的数据类型为数字。它表示将引用模块如不同文件引用了多少次，才能分离生成新代码文件。默认值为 1</li><li><strong>maxAsyncRequests：</strong> 该属性值的数据类型为数字，默认值为 <code>5</code>。它表示按需加载最大的并行请求数，针对异步。</li><li><strong>maxInitialRequests：</strong> 该属性值的数据类型为数字，默认值为 <code>3</code>。它表示单个入口文件最大的并行请求数，针对同步。</li><li><strong>automaticNameDelimiter：</strong> 该属性值的数据类型为字符串，默认值为 <code>~</code>。它表示分离后生成新代码文件名称的链接符，比如说 app1.js 和 app2.js 都引用了 <code>utils.js</code> 这个工具库，那么，最后打包后分离生成的公用文件名可能是 <code>xx~app1~app2.js</code> 这样的，即以 <code>~</code> 符号连接。</li><li><strong>name：</strong> 该属性值的数据类型可以是 布尔值 或者 函数（返回值为字符串），其中布尔值得为 <code>true</code>，此时，分离文件后生成的文件名将基于 <code>cacheGroups</code> 和 <code>automaticNameDelimiter</code>。如果设置为 <code>false</code>，则不会进行模块分离。 </li><li><strong>cacheGroups：</strong> 该属性值的数据类型为对象，它的值可以继承 <code>splitChunks.*</code> 中的内容。如果 <code>cacheGroups</code>存在与 <code>splitChunks.*</code> 同名的属性，则 <code>cacheGroups</code> 的属性值则直接覆盖 <code>splitChunks.*</code> 中设置的值。</li><li><strong>test：</strong> 该属性值的数据类型可以为 字符串 或 正则表达式，它规定了哪些文件目录的模块可以被分离生成新文件。</li><li><strong>priority：</strong> 该属性值的数据类型可以为数字，默认值为 <code>0</code>。它表示打包分离文件的优先级。</li><li><strong>reuseExistingChunk：</strong> 该属性值的数据类型可以为布尔值。它表示针对已经分离的模块，不再重新分离。</li></ul><p>那么问题来了，我们该如何理解这些属性配置？并且利用它们实现更加高效的打包？</p><p>其实没有什么，要验证这些配置参数，只不过是反复打包验证的过程。</p><h3 id="6-1-默认配置"><a href="#6-1-默认配置" class="headerlink" title="6.1 默认配置"></a>6.1 默认配置</h3><p>在开始验证之前，我们准备三个入口文件（app1、app2、app3）以及它们各自引用的模块（jQuery、Lodash、React均来自 node_modules，utils 则是本地定义的工具函数文件），其中分离打包采用默认的配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app1: <span class="string">'./src/js/app1.js'</span>, <span class="comment">// 引用了 jQuery、Lodash、utils</span></span><br><span class="line">    app2: <span class="string">'./src/js/app2.js'</span>, <span class="comment">// 引用了 jQuery、Lodash、utils</span></span><br><span class="line">    app3: <span class="string">'./src/js/app3.js'</span> <span class="comment">// 引用了 React、React-dom</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后，得到：</p><img src="/2018/06/09/webpack-split-chunks/splitchunk1-default.png" title="默认配置的分离打包"><p>可以看到，由于采用默认分离打包配置，即 <code>chunks: &#39;async&#39;</code>。而我们代码中没用使用到异步加载模块，此时打包，并没有分离出单独的模块文件。所以输出的文件是下面这三个。它们的内容分别为：</p><ul><li>app1.min.js：jQuery、Lodash、utils 的源码和 app1.js 的业务代码</li><li>app2.min.js：jQuery、Lodash、utils 的源码和 app2.js 的业务代码</li><li>app3.min.js：React、React-dom 的源码和 app3.js 的业务代码</li></ul><h3 id="6-2-分离第三方库"><a href="#6-2-分离第三方库" class="headerlink" title="6.2 分离第三方库"></a>6.2 分离第三方库</h3><p>要将第三方库分离出来，我们需要调整配置文件，设置 <code>chunks: &#39;all&#39;</code>，即表示让所有加载类型的模块在某些条件下都能打包：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后，得到：</p><img src="/2018/06/09/webpack-split-chunks/splitchunk2-chunks-all.png" title="chunks-all"><p>由于 jQuery、Lodash、React、React-dom 未压缩之前的源码都超过了30K，所以它们被分离成独立的文件。由于它们都来自 <code>node_modules</code>，所以这些分离文件的名称前缀是我们的配置 <code>vendors</code>， 接着使用 <code>automaticNameDelimiter</code> 的值（符号 ‘~’）来连接共同引入它们的业务文件名，如 <code>vendors~app1~app2.min.js</code> 和 <code>vendors~app3.min.js</code>。</p><p>它们的内容分别为：</p><ul><li>vendors~app1~app2.min.js：jQuery、Lodash的源码</li><li>app1.min.js：utils 的源码和 app1.js 的业务代码</li><li>app2.min.js：utils 的源码和 app2.js 的业务代码</li><li>vendors~app3.min.js：React、React-dom 的源码</li><li>app3.min.js：app3.js 的业务代码</li></ul><h3 id="6-3-分离工具函数"><a href="#6-3-分离工具函数" class="headerlink" title="6.3 分离工具函数"></a>6.3 分离工具函数</h3><p>在上面的打包中，我们发现，工具函数模块（utils）的源码被分别打包到了 app1.min.js 和 app2.min.js 这两个文件中，这显然是不对。之所以出现这种情况，是因为我们设置了 <code>minSize: 30000</code>，即分离成独立文件的最小体积为 30K，而这里的 工具函数（utils.js）只有几KB，所以，没被分离成单独的文件。</p><p>我们在 <code>cacheGroups</code> 中重新设置 <code>minSize</code> 的值，这样，就能覆盖 <code>splitChunks.*</code> 里面 <code>minSize</code> 的默认值：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minSize: <span class="number">0</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后，得到：</p><img src="/2018/06/09/webpack-split-chunks/splitchunk3-minsize.png" title="最小分离体积"><p>这样就分离出了 工具函数模块。它们的内容分别为：</p><ul><li>vendors~app1~app2.min.js：jQuery、Lodash的源码</li><li>default~app1~app2.min.js：utils 的源码</li><li>app1.min.js：app1.js 的业务代码</li><li>app2.min.js：app2.js 的业务代码</li><li>vendors~app3.min.js：React、React-dom 的源码</li><li>app3.min.js：app3.js 的业务代码</li></ul><h3 id="6-4-第三方库合并打包并重命名"><a href="#6-4-第三方库合并打包并重命名" class="headerlink" title="6.4 第三方库合并打包并重命名"></a>6.4 第三方库合并打包并重命名</h3><p>有的时候，我们希望将所有来自 <code>node_modules</code> 的第三方库都打包到同一个文件中。显然，上面的打包配置并没有满足这个条件。并且，我们还希望可以对打包后的文件名进行重命名。</p><p>要完成，只需要在 <code>cacheGroups</code> 设置 <code>name</code> 属性即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">          name: <span class="string">'lib'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minSize: <span class="number">0</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">          name: <span class="string">'utils'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后，得到：</p><img src="/2018/06/09/webpack-split-chunks/splitchunk3-name.png" title="分离打包文件合并并重命名"><p>这样不仅合并了所有来自 <code>node_modules</code> 的第三方库，还自定义了打包后的文件名称。它们的内容分别为：</p><ul><li>lib.min.js：jQuery、Lodash、React、React-dom 的源码 （由于包含的库都比较大，所有直接黄色了！！）</li><li>utils.min.js：utils 的源码</li><li>app1.min.js：app1.js 的业务代码</li><li>app2.min.js：app2.js 的业务代码</li><li>app3.min.js：app3.js 的业务代码</li></ul><p>如果你嫌打包后的业务文件大，还可以结合 <code>optimization.runtimeChunk</code>。它可以提取 entry chunk 中的 runtime函数部分，生成一个单独的文件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    runtimeChunk: &#123;</span><br><span class="line">      name: <span class="string">'manifest'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/06/09/webpack-split-chunks/optimization-runtimechunk.png" title="runtimechunk"><p>可以看到，打包后的业务文件（app1、app2、app3）体积都变小了。</p><p>另外， <code>cacheGroups</code> 中还有一个关于优先级 <code>priority</code> 的属性，由于一个模块可以被分配到多个缓存组中，优化策略会将模块分配至跟高优先级别的缓存组，这对于将这个模块分离到更大体积的js文件，减少请求数特别有用。</p><p>最后，需要说明的是，<code>test</code>、<code>priorty</code> 和 <code>reuseExistingChunk</code> 只能用于配置缓存组。</p>]]></content>
    
    <summary type="html">
    
      webpack分离第三方库、公用文件、工具函数
    
    </summary>
    
    
      <category term="webpack" scheme="http://yi-jy.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>NW.js 开发的相关问题</title>
    <link href="http://yi-jy.com/2018/05/27/question-about-nwjs/"/>
    <id>http://yi-jy.com/2018/05/27/question-about-nwjs/</id>
    <published>2018-05-27T14:48:21.000Z</published>
    <updated>2018-06-30T15:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用nwjs开发桌面应用，遇到了一些问题，为方便日后参考，所以在此把它们记录下来。之所以没用 electronjs，是因为公司产品主要面向教育行业工作人群，他们中XP系统的使用者，占了很大一部分比例。</p><a id="more"></a><h3 id="一、nwjs-客户端无法播放视频、音频"><a href="#一、nwjs-客户端无法播放视频、音频" class="headerlink" title="一、nwjs 客户端无法播放视频、音频"></a>一、nwjs 客户端无法播放视频、音频</h3><p>在做nwjs客户端开发时，发现客户端无法播放视频、音频。查资料说，这是由于MP3编码属于专利编码，非开源授权的，所以在nw.js中默认不支持MP3的播放，需要手动启用才行。</p><p>访问它的 <a href="https://github.com/iteufel/nwjs-ffmpeg-prebuilt/releases" target="_blank" rel="noopener">github主页</a>，找到对应本地版本号的 <code>ffmpeg.dll</code> 压缩包，并下载它。</p><p>解压后，在nwjs对应的目录，覆盖 <code>ffmpeg.dll</code> 文件，即可！</p><h3 id="二、windows-XP-的兼容性问题"><a href="#二、windows-XP-的兼容性问题" class="headerlink" title="二、windows XP 的兼容性问题"></a>二、windows XP 的兼容性问题</h3><p>由于公司产品主要面向教育行业工作人群，因此，这款基于nwjs开发的产品需要兼容XP。但当在XP系统进行测试时，结果发现无法启动：</p><img src="/2018/05/27/question-about-nwjs/nw-xp-compatible.png" title="XP系统无法兼容"><p>针对这个问题，官网给出了 <a href="https://github.com/nwjs/nw.js/issues/5166" target="_blank" rel="noopener">解决方案</a></p><blockquote><p>Google ended the support for XP in Chrome M50. NW.js LTS is based on the last compatible version of Chrome. So please use the LTS version (0.14.x) for XP support.</p></blockquote><p>大致的意思是说，Google 在 Chrome50 这个版本终止了对 xp系统的支持。而 NW.js LTS 版本是基于Chrome浏览器最后一个兼容版本，因此，要兼容 XP，请使用 <code>0.14.x</code> 这种长期支持（Long Term Support - LTS）版本。</p><p>并且，从 <a href="http://dl.nwjs.io/?spm=a2c4e.11153940.blogcont47275.10.1dc926e8bqdfvM" target="_blank" rel="noopener">下载列表</a> 页面可以看出，<code>0.14.7</code> 为 <code>0.14.x</code> 的最后一个版本。</p><p>所以，如果要兼容XP系统，并且最大利用 NW.js 的新特性，你可以使用 <code>0.14.7</code> 版本。</p><h3 id="三、nw-is-not-defined"><a href="#三、nw-is-not-defined" class="headerlink" title="三、nw is not defined"></a>三、nw is not defined</h3><p>默认情况下，启动nw客户端后，nw会在运行环境注入一个全局变量 <code>nw</code>，通过该变量，我们可以使用nw的相关API。</p><p>但我们在代码中使用 <code>nw.Window.get().maximize()</code> 来实现窗口最大化时，直接报错 <code>nw is not defined</code>。并且，如果按 <code>F12</code> 开启开发者工具，输入 <code>nw</code>，也会直接报 <code>nw is not defined</code>:</p><img src="/2018/05/27/question-about-nwjs/nw-is-not-defined.png" title="nw未定义报错"><p>有人也遇到类似的 <a href="https://github.com/nwjs/nw.js/issues/4937" target="_blank" rel="noopener">问题</a>，不过它是改变 <code>windows location</code> 遇到的。</p><p>解决方案是在 <code>package.json</code> 文件加入 <code>&quot;node-remote&quot;: &quot;&lt;all_urls&gt;&quot;</code> 字段，即：</p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="string">"node-remote"</span>: <span class="string">"&lt;all_urls&gt;"</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、顶部栏拖动"><a href="#四、顶部栏拖动" class="headerlink" title="四、顶部栏拖动"></a>四、顶部栏拖动</h3><p>由于默认的顶部栏都比较简陋（见图的上半部分）：</p><img src="/2018/05/27/question-about-nwjs/nw-top.png" title="nw头部"><p>通常情况我们会使用前端技术（html、css、js）来自定义顶部栏，再结合 nw 窗口操作的API（最大化、最小化、还原、关闭），便能完成默认顶部栏的功能。</p><p>但是，nw 貌似没有提供窗口拖动的API，这时，你只需要给自定义顶部栏容器（假设类名为 <code>top</code>）应用一行样式，即可实现拖动：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.top</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-app-region</span>: drag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要注意，如果配置文件中使用 <code>frame</code> 模式，即 <code>&quot;frame&quot;: true</code>，则自定义的顶部栏仍然无法拖动。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> package.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"window"</span>: &#123;</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="string">"frame"</span>: <span class="literal">true</span>, <span class="string">//</span> 无法拖动</span><br><span class="line">    <span class="string">"frame"</span>: fasle</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但还要注意，上面的样式可能会导致右边控制窗口的API（最大化、最小化、还原、关闭）无法使用。此时，你还需要对该控制区域禁用拖动：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.window-control</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-app-region</span>: no-drag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、版本提示"><a href="#五、版本提示" class="headerlink" title="五、版本提示"></a>五、版本提示</h3><p>本地开发环境下，启动 nw 客户端时，另外一个窗口有如下提示：</p><img src="/2018/05/27/question-about-nwjs/nw-version-warn-dev.png" title="版本提示dev版"><p>或者，打包完成后，生产环境下，运行 nw 客户端，也有类似英文的提示：</p><img src="/2018/05/27/question-about-nwjs/nw-version-warn-build.png" title="版本提示build版"><p>这是因为之前装过高版本的 nwjs，存在缓存问题。所以。。。</p><p>解决方案是：找到 <code>C:\Users\Administrator\AppData\Local</code> 这个路径，把 <code>nwjs</code>目录 以及 nw生成的相关应用程序目录（比如你利用nw生成的程序名为 app.exe，则删除app文件夹）全部删除。</p><h3 id="六、nw客户端不能启动"><a href="#六、nw客户端不能启动" class="headerlink" title="六、nw客户端不能启动"></a>六、nw客户端不能启动</h3><p>有的时候，本地开发环境下，在关闭了 nw客户端，希望通过命令行再次重启 nw客户端，会出现 nw客户端 无法启动的情况。</p><p>还有的时候，打包后的生产环境下，在关闭 nw客户端 后，希望双击 <code>xx.exe</code> 再次重启 nw客户端，也会出现 nw客户端 无法启动的情况。</p><p>查看 <code>Windows 任务管理器</code> 你会发现，虽然通过 命令行 或者 关闭按钮 关闭了 nw客户端，但它的进程却没有结束。所以，会出现 nw客户端 无法启动的情况。</p><p>最开始的解决方案是，手动在  <code>Windows 任务管理器</code> 面板结束有关应用程序的全部进程。</p><p>后面发现，可能与本地存在多个 nw版本 有关！</p><p>解决方案是：找到 <code>C:\Users\Administrator\AppData\Local</code> 这个路径，把 <code>nwjs</code>目录 以及 nw生成的相关应用程序目录（比如你利用nw生成的程序名为 app.exe，则删除app文件夹）全部删除。</p><p>另外，如果可以的话，尽可能在打包时，使用命令行去下载更新 nw的运行包（该操作，非必须）。</p><h3 id="七、无法使用-flash-播放"><a href="#七、无法使用-flash-播放" class="headerlink" title="七、无法使用 flash 播放"></a>七、无法使用 flash 播放</h3><p>在 nw 中嵌入 flash 时，会出现 “无法加载插件”，从而导致flash不能正常播放：</p><img src="/2018/05/27/question-about-nwjs/flash-load-error.png" title="flash播放失败"><p>之所以出现这种情况，是因为 nw 没有找到对应的 flash 插件。</p><p>解决方案：windows 系统下，通过 <code>C:\Windows\System32\Macromed\Flash</code> 打开 Flash 插件的目录，找到 <code>pepflashplayerxx_xx_x_x_xxx.dll</code> （其中 <code>x</code> 字母代表你本地安装的版本号）这个文件。</p><p>然后，在 nw 开发目录找到 sdk 包，并在这个 sdk 包的根目录新建 <code>PepperFlash</code> 文件夹，并把 <code>pepflashplayerxx_xx_x_x_xxx.dll</code> 文件放入其中。</p><p>最后，在项目开发根目录，找到 <code>package.json</code> 配置文件，指定 flash 插件的路径：</p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json`</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"chromium-args"</span>: <span class="string">"--ppapi-flash-path=PepperFlash/pepflashplayer64_25_0_0_171.dll"</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、nw打包后，文件资源无法正常读取"><a href="#八、nw打包后，文件资源无法正常读取" class="headerlink" title="八、nw打包后，文件资源无法正常读取"></a>八、nw打包后，文件资源无法正常读取</h3><p>最初开发完打包时，我们是把主程序和文件资源打包在一起，这显然不符合客户端程序开发的规范，会出现两个问题：</p><ul><li>如果文件资源很多，会导致打包的执行文件也很大</li><li>主程序无法读取其他文件资源（这显然不行的，比如一个播放器，难道只能播放它自身包含的视频？）</li></ul><p>但如果我们不把文件资源和主程序打包在一起，那么，又会导致文件资源无法正常读取（找不到资源路径）的问题。一般情况下，我们会把文件资源放在主程序的根目录。那么，要解决这个路径问题，其实，最关键的是，要在主程序读取文件资源时，首先需要找到主程序路径：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNwRunPath</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> installPath = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> &#123; execPath &#125; = process;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (execPath.includes(<span class="string">'MacOS'</span>)) &#123;</span><br><span class="line">    installPath = execPath.replace(<span class="string">'nwjs/0.14.7-sdk/osx64/nwjs.app/Contents/Versions/50.0.2661.102/nwjs Helper.app/'</span> +</span><br><span class="line">      <span class="string">'Contents/MacOS/nwjs Helper'</span>,</span><br><span class="line">      <span class="string">''</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (execPath.includes(<span class="string">'nw.exe'</span>)) &#123;</span><br><span class="line">    installPath = execPath.replace(<span class="string">'nwjs\\0.14.7-sdk\\win64\\nw.exe'</span>, <span class="string">''</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    installPath = execPath.substring(<span class="number">0</span>, execPath.lastIndexOf(<span class="string">'\\'</span>) + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> installPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数可得到主程序的运行路径，然后，我们再通过主程序路径，去找对应的文件资源目录则非常容易了。</p><h3 id="九、nwjs应用图标无法正常显示"><a href="#九、nwjs应用图标无法正常显示" class="headerlink" title="九、nwjs应用图标无法正常显示"></a>九、nwjs应用图标无法正常显示</h3><h4 id="9-1-本地开发时，工具栏图标显示不正常"><a href="#9-1-本地开发时，工具栏图标显示不正常" class="headerlink" title="9.1 本地开发时，工具栏图标显示不正常"></a>9.1 本地开发时，工具栏图标显示不正常</h4><p>由于该nwjs项目在本地开发及浏览器端打包方面是基于 webpack 的，所以，我是先使用 webpack-dev-server 来启动服务，再通过nodejs去执行 nw-sdk 包中的 nw.exe，从而启动nw客户端。</p><p>在没设置工具栏图标之前，是这样的（最后两个分别是 nw客户端、nw客户端开发者工具）：</p><img src="/2018/05/27/question-about-nwjs/app-icon-dev1.png" title="开发环境工具栏图标1"><p>我们需要在项目根目录的配置文件设置nwjs运行的的图标（你也可以设置宽高或者其他属性）：</p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"window"</span>: &#123;</span><br><span class="line">    <span class="string">"width"</span>: <span class="number">1024</span>,</span><br><span class="line">    <span class="string">"height"</span>: <span class="number">768</span>,</span><br><span class="line">    <span class="string">"min_width"</span>: <span class="number">1024</span>,</span><br><span class="line">    <span class="string">"min_height"</span>: <span class="number">768</span>,</span><br><span class="line">...</span><br><span class="line">    <span class="string">"icon"</span>: <span class="string">"src/res/images/app/app.png"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置完后，再次启动服务，就得到预期的效果：</p><img src="/2018/05/27/question-about-nwjs/app-icon-dev2.png" title="开发环境工具栏图标2"><h4 id="9-2-打包后，工具栏图标和预览图标无法正常显示"><a href="#9-2-打包后，工具栏图标和预览图标无法正常显示" class="headerlink" title="9.2 打包后，工具栏图标和预览图标无法正常显示"></a>9.2 打包后，工具栏图标和预览图标无法正常显示</h4><p>当开发完成，通过 <code>nw-builder</code> 打包后，在打包目录中启动 exe 文件，会发现工具栏图标和预览图标显示的是 <code>nwjs(node-webkit)</code> 的默认图标：</p><img src="/2018/05/27/question-about-nwjs/app-icon-build1.png" title="生产环境图标1"><p>并且，当把打包的目录或者 exe 文件复制到其他文件夹，不仅工具栏图标和预览图标，exe 文件的图标也变成了 <code>nwjs(node-webkit)</code> 的默认图标，这显然是无法接受的。</p><p>这就需要在 <code>nw-builder</code> 打包之前，将图标复制到 nwjs 要打包的目录（webpack编译后的文件夹一般为 dist 目录）：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> distDir = path.resolve(__dirname, <span class="string">'dist'</span>);</span><br><span class="line"><span class="keyword">const</span> appIconUrl = path.resolve(<span class="string">'./'</span>, <span class="string">'src/res/images/app-old/app.png'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildConfig = &#123;</span><br><span class="line">  name: <span class="string">'app'</span>,</span><br><span class="line">  <span class="built_in">window</span>: &#123;</span><br><span class="line">    icon: <span class="string">'app.png'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  main: <span class="string">'index.html'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fs.copyFile(appIconUrl, path.resolve(<span class="string">'./'</span>, <span class="string">'dist/app.png'</span>), <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 写入nw运行的配置文件</span></span><br><span class="line">  fs.writeFileSync(path.resolve(distDir, <span class="string">'package.json'</span>), <span class="built_in">JSON</span>.stringify(buildConfig));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// nw-builder 打包操作</span></span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再次打包后发现，发现工具栏图标变成我们自定义的了，但是，但是右侧预览图标还是一直显示 <code>nwjs(node-webkit)</code> 的默认图标。</p><img src="/2018/05/27/question-about-nwjs/app-icon-build2.png" title="生产环境图标2"><p>和工具栏图标不同，对于右侧预览图，最坑爹（最坑爹！）的是，由于打包后文件目录存在缓存，这就导致不是每一次打包后，exe应用图标都会及时按照每次修改的源码进行更新。换言之，即使改对了，打包后生成的应用图标可能还是原来的。</p><p>因此，在排查问题上非常耗时！！为了这个问题，几乎折腾了一天了！！！</p><p>再查找各方资料，经多次尝试后发现，<code>nw-builder</code> 配置文件（假设为 nwbuild.config.js）中对 windows 系统的应用图标（ico格式，假设为 app.ico），必须是 <code>256*256</code> 尺寸这么一个尺寸的图标（网上资料都说要 128 * 128 尺寸，其实根本不对！！！）：</p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nwbuild.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  winIco: <span class="string">'./src/res/images/app/app.ico'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于，再更新图标后，应用图标、底部栏图标、右侧预览图标，都显示成我们自定义的图标。并且，把打包目录或者 exe 文件复制到其他文件夹，也显示的是我们自定义的图标。</p><img src="/2018/05/27/question-about-nwjs/app-icon-build3.png" title="生产环境图标3"><p>后来针对上面的缓存问题，我想了这么两个方案：</p><ul><li>尽可能在每次修改时，换掉图标的名称及生成路径（不一定会生效）</li><li>将修改后整个项目的源码复制到其他新文件夹，在新文件夹重新编译打包（完全规避了缓存问题。但每次都要按照一堆依赖，比较繁琐）</li></ul><p>另外，图标转换其他格式的方式如下：</p><ul><li><p>将 png 转换为 ico 格式，可通过这个站点：<a href="https://www.icoconverter.com/" target="_blank" rel="noopener">icoconverter</a> ，转换时，<code>Sizes</code> 选项选择 256 pixels 的规格，<code>Bit depth</code> 选项则选择 32 bits 的规格。</p></li><li><p>将 png 转换为 icns 格式，则可通过这个站点：<a href="https://cloudconvert.com/png-to-icns" target="_blank" rel="noopener">cloudconvert-png-to-icns</a></p></li></ul><h4 id="9-3-更改图标其他方案"><a href="#9-3-更改图标其他方案" class="headerlink" title="9.3 更改图标其他方案"></a>9.3 更改图标其他方案</h4><p>如果不想用程序代码来更换图标，你也可以使用桌面应用资源编译器工具。其中，目前主流的，应该是 <a href="http://www.angusj.com/resourcehacker/" target="_blank" rel="noopener">resourcehacker</a> 。</p><h3 id="十、无法使用-alert、prompt、confirm等系统弹框"><a href="#十、无法使用-alert、prompt、confirm等系统弹框" class="headerlink" title="十、无法使用 alert、prompt、confirm等系统弹框"></a>十、无法使用 alert、prompt、confirm等系统弹框</h3><p>在程序中使用 <code>alert</code>、 <code>prompt</code> 等系统弹框，会导致nw程序奔溃。但在某些同事的电脑上，则不会出现该问题。经过多次尝试，暂无解决方案…</p><h3 id="十一、draftJs光标错乱的问题"><a href="#十一、draftJs光标错乱的问题" class="headerlink" title="十一、draftJs光标错乱的问题"></a>十一、draftJs光标错乱的问题</h3><p>由于项目中涉及文本输入，所以用到了 facebook 的一个富文本react组件 - <a href="https://github.com/facebook/draft-js" target="_blank" rel="noopener">draft-js</a> 。但一开始出现光标错乱的问题，见图：</p><img src="/2018/05/27/question-about-nwjs/draftjs-input1.gif" title="输入光标错乱"><p>可以看到，输入第一个字符串正常，但输入第二个字符时，光标会跳到最前面。当尝试删除这些字符时，它们的顺序又正常了。对于这种问题，一开始百思不得其解，因为，我在其他项目里（浏览器端）该组件功能是没问题的。</p><p>后来发现，是由于我在webpack中设置了 nwjs 在 nodejs 环境下运行。解决方法很简单，因为 nodejs 环境的全部变量是 <code>global</code>，只需要针对该环境把 <code>getSelection</code> 方法重新赋值即可：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">global</span>.getSelection = <span class="built_in">window</span>.getSelection.bind(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><img src="/2018/05/27/question-about-nwjs/draftjs-input2.gif" title="输入光标正常"><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul><li><a href="https://libraries.io/github/mingxinstar/NW.js-Practice" target="_blank" rel="noopener">NW.js-Practice</a></li><li><a href="https://github.com/nwjs/nw.js/issues/5761" target="_blank" rel="noopener">Upadte version and want reset use old version</a></li><li><a href="http://docs.nwjs.io/en/latest/References/Command%20Line%20Options/#-user-data-dir" target="_blank" rel="noopener">user-data-dir</a></li><li><a href="https://github.com/nwjs/nw.js/issues/6271" target="_blank" rel="noopener">Flash player not work</a></li></ul>]]></content>
    
    <summary type="html">
    
      NW.js 开发的相关问题
    
    </summary>
    
    
      <category term="NW.js" scheme="http://yi-jy.com/tags/NW-js/"/>
    
      <category term="Node.js" scheme="http://yi-jy.com/tags/Node-js/"/>
    
  </entry>
  
</feed>
