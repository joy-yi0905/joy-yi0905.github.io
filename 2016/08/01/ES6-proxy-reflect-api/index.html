<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/>

  
  <meta name="author" content="易建勇,YI_joy">
  

  
  <meta name="description" content="ES6-proxy-reflect-api | 前端技术空间">
  

  
  <meta name="keywords" content="es6 Proxy api Reflect api">
  

  

  <title>ES6中 Proxy 与 Reflect API | 前端技术空间</title>

  <link rel="stylesheet" href="/css/blog.css">
</head>
<body>

<div class="blog">

<div class="navigation">
  <ul class="nav-list">
    
      <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
    
      <li class="nav-item"><a class="nav-link" href="/archives">Archives</a></li>
    
  </ul>
</div>

<div class="post">

  <h1 class="post-title">ES6中 Proxy 与 Reflect API</h1>

  <time class="post-time">2016-08-01</time>

  <div class="post-content">
    <p>随着JavaScript的不断发展，开发者对于这门语言的开发越来越深入。为此，ES6 引入了 proxy 和 reflect API，给开发者对于JavaScript的底层操作，提供了更多的选择和可能。</p>
<p>通过这两个API，我们可以拦截JavaScript方法中的一些默认行为，从而在这些默认行为的基础上进行相关操作以及调整（比如，属性查找，赋值，枚举，函数调用等等）。这样，就相当于在语言层面上重新定义了相关方法。<a id="more"></a></p>
<p>接下来，我们来看看这两个API的相关内容。</p>
<h2 id="一、Proxy"><a href="#一、Proxy" class="headerlink" title="一、Proxy"></a>一、Proxy</h2><p>从字面意思来说，Proxy 表示代理的意思，这里可以理解为通过 Proxy 这个 API 在原有的基础上代理某些操作。</p>
<p>由于 Porxy 是针对JavaScript的底层操作，因此，也被成为 “元编程”（Meta programming）。它的基本语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<p>通过 Proxy 构造函数创建了一个实例，该实例接收两个参数，<code>target</code> 表示要拦截的对象。而 <code>handler</code> 也是一个对象，其中定义拦截的内容。</p>
<p>比如，最简单的拦截，获取属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.b); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>obj</code> 对象上由于没有给属性 <code>a</code> 和 <code>b</code> 赋值，所以它们的值都是 undefined。然后，我们通过 Proxy 重新定义了 <code>get</code> 方法，并且在方法中返回了 10。虽然 <code>proxy</code> 对象上也没有给属性 <code>a</code> 和 <code>b</code> 赋值，但它们的值却都是 10。</p>
<p>文章开头说到，是通过改变某些方法的默认行为，因此，我们来看看是哪些方法，怎么用？</p>
<h3 id="1-1-set-target-key-value-receiver"><a href="#1-1-set-target-key-value-receiver" class="headerlink" title="1.1 set(target, key, value, receiver)"></a>1.1 set(target, key, value, receiver)</h3><p>该方法主要用于拦截属性的设置。它的使用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'proxy对象的属性值必须为数字'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.a = <span class="number">5</span>;</span><br><span class="line">proxy.b = <span class="number">0.2</span>;  </span><br><span class="line">proxy.c = <span class="string">'c'</span>; <span class="comment">// 报错：proxy对象的属性值必须为数字</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，通过 Proxy 重新定义了 set 方法。规定 <code>proxy</code> 对象的属性值必须得是数字，否者就报错。</p>
<h3 id="1-2-get-target-key-receiver"><a href="#1-2-get-target-key-receiver" class="headerlink" title="1.2 get(target, key, receiver)"></a>1.2 get(target, key, receiver)</h3><p>该方法主要用于拦截属性的读取。它的使用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">return</span> target[key];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'对象proxy不存在'</span> + key + <span class="string">'属性'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">proxy.a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.a); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.b); <span class="comment">// 报错：对象proxy不存在b属性</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，如果对象上没有设置相应的属性，读取这个属性值会得到一个 <code>undefined</code>，比如上面代码中的 <code>obj.a</code> 。虽然返回的值 <code>undefined</code> 意思为 未定义，但总感觉有些别扭。</p>
<p>于是，我们通过 Proxy 重新定义了 get 方法。有值就读取对应的值，没有值就抛出错误。</p>
<h3 id="1-3-has-target-key"><a href="#1-3-has-target-key" class="headerlink" title="1.3 has(target, key)"></a>1.3 has(target, key)</h3><p>该方法主要用于拦截 HasProperty 操作。我们通常都是用 <code>in</code> 操作符来判断一个属性是否存在于对象中，如果在对象本身，或者原型上找到这个属性，则该操作将返回 true。反之，如果不找到相应的对象，则返回 false。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'cyclone'</span>,</span><br><span class="line">    age: <span class="string">'29'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span> <span class="keyword">in</span> person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>而 <code>in</code> 的底层操作主要是应用了HasProperty操作。 所以，<code>has(target, key)</code> 的使用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'cyclone'</span>,</span><br><span class="line">    age: <span class="string">'29'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'age'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'保密哦！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    has: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'age'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// "cyclone"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.age); <span class="comment">// "保密哦！"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这里的代码有点特别。我们在 <code>handler</code> 中定义了两个拦截操作，有 <code>get</code> 和 <code>has</code>。可以看到，我们可以正常读取 <code>name</code> 属性，但是 <code>age</code> 属性被隐藏起来。</p>
<p>接着，我们使用 <code>in</code> 操作符来探测 <code>age</code> 属性。因为我们在拦截行为中进行了判断处理，所以外部便找不到 <code>age</code> 属性（返回 false）。</p>
<h3 id="1-4-defineProperty-target-key"><a href="#1-4-defineProperty-target-key" class="headerlink" title="1.4 defineProperty(target, key)"></a>1.4 defineProperty(target, key)</h3><p>该方法主要用于拦截 Object.defineProperty 操作。默认情况下，Object.defineProperty 是在一个对象上定义一个新的属性，或修改一个已经存在的属性。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: <span class="string">'cyclone'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'age'</span>, &#123;</span><br><span class="line">    value: <span class="number">29</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: "cyclone", age: 29&#125;</span></span><br></pre></td></tr></table></figure>
<p>于是，<code>defineProperty(target, key)</code> 方法的拦截操作可以写成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'cyclone'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    defineProperty: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'name'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(target, key, &#123;<span class="attr">value</span>: value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">'yix'</span>;</span><br><span class="line">proxy.job = <span class="string">'designer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// "cyclone"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.job); </span><br><span class="line"><span class="comment">// &#123;value: "designer", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，尝试着覆盖 <code>name</code> 属性，结果失败了。但却成功的增加了 <code>job</code> 属性。</p>
<h3 id="1-5-deleteProperty-target-key"><a href="#1-5-deleteProperty-target-key" class="headerlink" title="1.5 deleteProperty(target, key)"></a>1.5 deleteProperty(target, key)</h3><p>该方法主要用于拦截 delete 操作。我们知道，<code>delete</code> 操作符可用于删除对象属性，当删除成功时返回 true，否者将返回 false。并且，严格模式下，当删除一个不可配置的属性，<code>delete</code> 操作符将会抛出一个错误。</p>
<p>我们还知道，一般前面以下划线 <code>_</code> 开头的属性，被称为内部属性。</p>
<p>现在我不使用严格模式，也能实现删除以下划线 <code>_</code> 开头的属性，并将会报错的效果。只需要这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'cyclone'</span>,</span><br><span class="line">    _age: <span class="string">'29'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    deleteProperty: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">delete</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> proxy.name); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> proxy._age); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy._age); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
<p>这里首先删除了 <code>name</code> 属性，可以看到删除成功并返回了 true，同时再次读取 <code>name</code> 属性时为 undefined。</p>
<p>然后，我们再删除 <code>_age</code> 属性。结果删除不成功并返回了 false（为了方便后面读取，所以这里没用 throw Error），所以后面也能正常读取到 <code>_age</code> 属性。</p>
<h3 id="1-6-setPrototypeOf-target-proto"><a href="#1-6-setPrototypeOf-target-proto" class="headerlink" title="1.6 setPrototypeOf(target, proto)"></a>1.6 setPrototypeOf(target, proto)</h3><p>该方法主要用于拦截 Object.setPrototypeOf() 操作。默认情况下，Object.setPrototypeOf() 是将对象的原型(即对象的[[Prototype]]内部属性)设置为另一个对象或者null。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'yix'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, <span class="built_in">window</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>person</code> 的原型是普通的对象。然后我们将 <code>person</code> 原型设置为 <code>window</code>，此时通过内置属性 <code>__proto__</code> 再去读取它的原型，便得到 <code>window</code>。最后，将 <code>person</code> 原型设置为 <code>null</code>，因为 <code>null</code> 比较特殊，所以，此时得到是 <code>undefined</code> 。</p>
<p>接着，我们来看 <code>setPrototypeOf(target, proto)</code> 的使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'yix'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    setPrototypeOf: <span class="function"><span class="keyword">function</span>(<span class="params">target, proto</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'该实例不允许改变原型'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, <span class="built_in">window</span>); <span class="comment">// 报错：该实例不允许改变原型</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，希望将 <code>person</code> 对象的原型改为 <code>window</code>，结果被拦截了，并抛出一个错误。</p>
<h3 id="1-7-getPrototypeOf-target"><a href="#1-7-getPrototypeOf-target" class="headerlink" title="1.7 getPrototypeOf(target)"></a>1.7 getPrototypeOf(target)</h3><p>该方法主要用于拦截 Object.getPrototypeOf() 操作。 Object.getPrototypeOf() 的功能是获取指定对象的原型（即内部属性[[Prototype]]）。 </p>
<p>所以，<code>getPrototypeOf(target)</code> 方法可以这样用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'yix'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    getPrototypeOf: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不能获取该实例的原型'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(proxy); <span class="comment">// 报错：不能获取该实例的原型</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们禁止了通过 <code>Object.getPrototypeOf()</code> 来读取原型。</p>
<h3 id="1-8-apply-target-object-args"><a href="#1-8-apply-target-object-args" class="headerlink" title="1.8 apply(target, object, args)"></a>1.8 apply(target, object, args)</h3><p>该方法主要用于拦截函数的调用。 它的用法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(getData, &#123;</span><br><span class="line">    apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, ctx, args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy(<span class="number">2</span>, <span class="string">'b'</span>)); <span class="comment">// [2, "b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="string">'c'</span>)); <span class="comment">// [3, "c"]</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.apply(<span class="literal">null</span>, [<span class="number">4</span>, <span class="string">'d'</span>])); <span class="comment">// [4, "d"]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，无论是函数的普通调用，还是通过 call 或者 apply 调用，这些统统被拦截了。</p>
<h3 id="1-9-construct-target-args"><a href="#1-9-construct-target-args" class="headerlink" title="1.9 construct(target, args)"></a>1.9 construct(target, args)</h3><p>该方法主要用于拦截 new 操作符的相关操作。 它的用法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Person, &#123;</span><br><span class="line">    construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">        args[<span class="number">0</span>] = args[<span class="number">0</span>] + <span class="string">'_'</span> + <span class="string">'cyclone'</span>;</span><br><span class="line">        <span class="keyword">return</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = proxy(<span class="string">'yix'</span>),</span><br><span class="line">    newP = <span class="keyword">new</span> proxy(<span class="string">'yix'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// "yix"</span></span><br><span class="line"><span class="built_in">console</span>.log(newP); <span class="comment">// ["yix_cyclone"]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，正常调用 <code>proxy</code> ，返回的值为传入的参数。而当使用 <code>new</code> 调用 <code>proxy</code> 则被拦截了，我们对返回值进行了加工。所以，最后得到 <code>yix_cyclone</code>。</p>
<p>这里特别要注意，<code>construct</code> 方法必须的返回对象。否者，会出现报错。这也是为什么我这里返回的是 <code>args</code> 而不是 <code>args[0]</code> 的原因。</p>
<h3 id="1-10-ownKeys-target"><a href="#1-10-ownKeys-target" class="headerlink" title="1.10 ownKeys(target)"></a>1.10 ownKeys(target)</h3><p>该方法主要用于拦截内部方法 [[OwnPropertyKeys]] 的相关操作。 涉及这些相关操作的方法有：</p>
<ul>
<li>Object.keys()</li>
<li>Object.getOwnPropertyNames()</li>
<li>Object.getOwnPropertySymbols()</li>
<li>Object.assign() </li>
</ul>
<p>Object.keys()，它的功能是返回一个由给定对象的所有可枚举自身属性的属性名组成的数组。它的基本功能如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr)); <span class="comment">// ["0", "1", "2"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">'yix'</span>, <span class="attr">job</span>: <span class="string">'web'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)); <span class="comment">// ["name", "job"]</span></span><br></pre></td></tr></table></figure>
<p>那么它对应的拦截方法是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    job: <span class="string">'web'</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    ownKeys: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'name'</span>, <span class="string">'job'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy); <span class="comment">// Proxy &#123;name: "yix", job: "web", age: 29&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)); <span class="comment">// ["name", "job", "age"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(proxy)); <span class="comment">// ["name", "job"]</span></span><br></pre></td></tr></table></figure>
<p>这里只能读取到 <code>name</code> 和 <code>job</code> 的属性，其他方法都是类似。</p>
<h3 id="1-11-getOwnPropertyDescriptor-target-key"><a href="#1-11-getOwnPropertyDescriptor-target-key" class="headerlink" title="1.11 getOwnPropertyDescriptor(target, key)"></a>1.11 getOwnPropertyDescriptor(target, key)</h3><p>该方法主要用于拦截 Object.getOwnPropertyDescriptor() 的相关操作。Object.getOwnPropertyDescriptor() 的功能是返回指定对象上一个自有属性对应的属性描述符。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptor); <span class="comment">// &#123;value: "yix", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样就获得了一个 <code>obj</code> 对象有关 <code>name</code> 属性的一个描述符。</p>
<p>那么，相应的拦截行为可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    job: <span class="string">'web'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    getOwnPropertyDescriptor: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'job'</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);</span><br><span class="line">            descriptor[<span class="string">'value'</span>] = <span class="string">'tester'</span>;</span><br><span class="line">            <span class="keyword">return</span> descriptor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// Object &#123;value: "yix", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'job'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "tester", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，对 <code>name</code> 属性使用默认行为。而对 <code>job</code> 属性则进行拦截，将它的属性值更改为 tester 。</p>
<h3 id="1-12-isExtensible-target"><a href="#1-12-isExtensible-target" class="headerlink" title="1.12 isExtensible(target)"></a>1.12 isExtensible(target)</h3><p>该方法主要用于拦截 Object.isExtensible() 的相关操作。Object.isExtensible() 的功能是判断一个对象是否是可扩展（是否可以在它上面添加新的属性）。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seal = &#123;<span class="attr">name</span>: <span class="string">'yix'</span>&#125;,</span><br><span class="line">    freeze = &#123;<span class="attr">name</span>: <span class="string">'yix'</span>&#125;,</span><br><span class="line">    sealed = <span class="built_in">Object</span>.seal(seal),</span><br><span class="line">    frozen = <span class="built_in">Object</span>.freeze(freeze);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密封和冻结的对象，都不能扩展</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(sealed)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(frozen)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>所以，我们可以通过 <code>isExtensible(target)</code> 方法来拦截默认行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        target.whatever = <span class="string">'xx'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy); <span class="comment">// &#123;whatever: "xx"&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里，我们只是简单的在 <code>isExtensible</code> 方法中给 <code>obj</code> 新增了一个属性。因为该方法的使用还是有很强的限制的，比如：</p>
<ol>
<li><code>isExtensible</code> 方法最终返回的值都会转换为布尔值（这里的 1 被转为了 true）</li>
<li><code>isExtensible</code> 方法返回的布尔值必须和 <code>Object.isExtensible()</code> 执行的结果一致，否者会报错（如果这里把 1 换成 0，则报错）。</li>
</ol>
<h3 id="1-13-preventExtensions-target"><a href="#1-13-preventExtensions-target" class="headerlink" title="1.13 preventExtensions(target)"></a>1.13 preventExtensions(target)</h3><p>该方法主要用于拦截 Object.preventExtensions() 的相关操作。Object.preventExtensions() 的功能是让一个对象变的不可扩展（即不能在它上面添加新的属性）,并返回原来的对象。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'yix'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">obj.job = <span class="string">'web'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: "yix"&#125;</span></span><br></pre></td></tr></table></figure>
<p>由上面的代码，可以看到一开始 <code>obj</code> 是可扩展的。被应用了 <code>Object.preventExtensions</code> 后，便不能扩展了，添加 <code>job</code> 属性也不成功。</p>
<p>再来看看，<code>preventExtensions(target)</code> 的拦截行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'yix'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    preventExtensions: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.preventExtensions(proxy)); </span><br><span class="line"><span class="comment">// 报错：'preventExtensions' on proxy: trap returned truish but the proxy target is extensible</span></span><br></pre></td></tr></table></figure>
<p>这里的拦截行为报错了，因为 <code>obj</code> 对象是可扩展的。然后，我们把它变为不可扩展：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'yix'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    preventExtensions: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        target.whatever = <span class="string">'xx'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.preventExtensions(proxy)); <span class="comment">// Proxy &#123;name: "yix"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy); <span class="comment">// Proxy &#123;name: "yix"&#125;</span></span><br></pre></td></tr></table></figure>
<p>此时，拦截行为不再报错了，但由于 <code>obj</code> 不能扩展了，所以 <code>whatever</code> 属性将添加失败，最终只是返回了原对象 <code>{name: &quot;yix&quot;}</code>。</p>
<h3 id="Proxy-revocable-可撤销的-proxy"><a href="#Proxy-revocable-可撤销的-proxy" class="headerlink" title="Proxy.revocable() - 可撤销的 proxy"></a>Proxy.revocable() - 可撤销的 proxy</h3><p>一般情况下，一旦 Proxy 被创建，Proxy 就不能和 targe 解绑，上文提到的所有例子都是这种类型。但在某些特殊情况下，你只是想在暂时使用 Proxy，而在后面撤销它的相关功能。</p>
<p>那么，你可以通过 <code>Proxy.revocable()</code> 方法来创建一个可撤销的 Proxy，它返回一个对象，该对象包含以下属性：</p>
<ul>
<li>proxy： 撤销的 proxy 对象</li>
<li>revoke：调用撤销 proxy 的函数</li>
</ul>
<p>当不需要它的功能时，只需要调用 <code>revoke()</code> 方法即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(person, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// "yix"</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// 报错：Cannot perform 'get' on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，创建了一个可撤销的 Proxy。这里用到了解构，将 <code>Proxy.revocable()</code> 方法返回对象的同名属性赋值给了 proxy 和 revoke 这两个变量。当调用 <code>revoke()</code> 后，有关 Proxy 的相关联系全部被切断了，所以运行 <code>proxy.name</code> 时将出现报错。  </p>
<h2 id="二、Reflect"><a href="#二、Reflect" class="headerlink" title="二、Reflect"></a>二、Reflect</h2><p>与 Proxy 相比，虽然 Reflect API 设计的目的也是用于弥补和完善 Javascrpt 的若干缺陷。但它更侧重于将已有的 JavaScript 方法或者运算符（in、delete等）的相关操作进行重新包装，从而让这些方法看上去更统一，使用起来也更简洁。</p>
<p>我们直接进入主题，看看它主要重新包装了哪些方法，以及它们的用法？</p>
<h3 id="2-1-Reflect-set-target-key-value-receiver"><a href="#2-1-Reflect-set-target-key-value-receiver" class="headerlink" title="2.1 Reflect.set(target, key, value[, receiver])"></a>2.1 Reflect.set(target, key, value[, receiver])</h3><p>该方法替代类似 target[key] = val 这样的操作，用于设置对象的属性，返回一个布尔值，表示是否设置成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(person, <span class="string">'name'</span>, <span class="string">'yix'</span>);</span><br><span class="line"><span class="built_in">Reflect</span>.set(person, <span class="string">'job'</span>, <span class="string">'web'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "yix", job: "web"&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>person</code> 对象设置了两个属性。</p>
<p>需要说明的是，该方法还接收第四个参数（可选）- receiver。这个参数的作用域是在 target 中，来看下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    set define(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">age</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(person, <span class="string">'age'</span>, <span class="number">10</span>, p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123;age: 10&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>p</code> 对象因为应用了 <code>person</code> 中的 set 方法，所以它的 <code>age</code> 属性值变为了 10 。</p>
<h3 id="2-2-Reflect-get-target-key-receiver"><a href="#2-2-Reflect-get-target-key-receiver" class="headerlink" title="2.2 Reflect.get(target, key[, receiver])"></a>2.2 Reflect.get(target, key[, receiver])</h3><p>该方法替代类似 target[key] 这样的操作，用于获取对象身上某个属性的值，返回一个属性值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    job: <span class="string">'web'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.get(person, <span class="string">'name'</span>)); <span class="comment">// "yix"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.get(person, <span class="string">'job'</span>)); <span class="comment">// "web"</span></span><br></pre></td></tr></table></figure>
<p>另外，该方法还接收第四个参数（可选）- receiver。这个参数的作用域是在 target 中，来看下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    job: <span class="string">'web'</span>,</span><br><span class="line">    get join() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' work as a '</span> + <span class="keyword">this</span>.job;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    name: <span class="string">'cyclone'</span>,</span><br><span class="line">    job: <span class="string">'designer'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.get(person, <span class="string">'join'</span>, p)); <span class="comment">// "cyclone work as a designer"</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>p</code> 对象因为应用了 <code>person</code> 中的 get 方法，所以它最终返回了 “cyclone work as a designer” 。</p>
<h3 id="2-3-Reflect-has-target-key"><a href="#2-3-Reflect-has-target-key" class="headerlink" title="2.3 Reflect.has(target, key)"></a>2.3 Reflect.has(target, key)</h3><p>该方法替代类似 key in target 这样的操作，用于判断一个对象是否存在某个属性，返回一个布尔值，表示是否存在。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.has(person, <span class="string">'name'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.has(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="string">'b'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-Reflect-defineProperty-target-key-desc"><a href="#2-4-Reflect-defineProperty-target-key-desc" class="headerlink" title="2.4 Reflect.defineProperty(target, key, desc)"></a>2.4 Reflect.defineProperty(target, key, desc)</h3><p>该方法替代类似 Object.defineProperty() 这样的操作，用于给对象添加或修改属性，返回一个布尔值，表示属性是否被添加或修改成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.defineProperty(person, <span class="string">'name'</span>, &#123;<span class="attr">value</span>: <span class="string">'cyclone'</span>&#125;)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty(person, <span class="string">'job'</span>, &#123;<span class="attr">value</span>: <span class="string">'u guess'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "cyclone", job: "u guess"&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，首先成功的修改了 <code>name</code> 属性，然后再添加了 <code>job</code> 属性。</p>
<h3 id="2-5-Reflect-deleteProperty-target-key"><a href="#2-5-Reflect-deleteProperty-target-key" class="headerlink" title="2.5 Reflect.deleteProperty(target, key)"></a>2.5 Reflect.deleteProperty(target, key)</h3><p>该方法替代类似 delete target[key] 这样的操作，用于删除对象上的某个属性，返回一个布尔值，表示属性是否被删除成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    job: <span class="string">'web'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.deleteProperty(person, <span class="string">'name'</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;job: "web"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(person);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.deleteProperty(person, <span class="string">'job'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在这里，首先成功删除了 <code>name</code> 属性。接着，我们将对象冻结起来，当再次尝试删除 <code>job</code> 属性时，返回了 false，也就是说，删除该属性不成功。</p>
<p>注意，如果删除对象上的一个不存在的属性，无论这个对象是否冻结，该方法都返回 true。</p>
<h3 id="2-6-Reflect-setPrototypeOf-target-prototype"><a href="#2-6-Reflect-setPrototypeOf-target-prototype" class="headerlink" title="2.6 Reflect.setPrototypeOf(target, prototype)"></a>2.6 Reflect.setPrototypeOf(target, prototype)</h3><p>该方法替代类似 Object.setPrototypeOf() 这样的方法，用于设置目标对象的 <code>__proto__</code> 属性（原型），返回一个布尔值，表示原型是否被设置成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'yix'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.setPrototypeOf(person, <span class="built_in">window</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// "yix"</span></span><br></pre></td></tr></table></figure>
<p>一开始，因为 <code>person</code> 中没有定义 <code>name</code> 属性，所以返回了 <code>undefined</code>。当我们将 <code>person</code> 的原型设置为 <code>window</code> 后，程序就会从 <code>person</code> 对象的原型（即 window）中查询 <code>name</code> 的值。</p>
<h3 id="2-7-Reflect-getPrototypeOf-target"><a href="#2-7-Reflect-getPrototypeOf-target" class="headerlink" title="2.7 Reflect.getPrototypeOf(target)"></a>2.7 Reflect.getPrototypeOf(target)</h3><p>该方法替代类似 Object.getPrototypeOf() 这样的方法，用于获取目标对象的 <code>__proto__</code> 属性（原型），并返回该原型，如果没有原型，则返回 null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.getPrototypeOf(p) === Person.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code> 是构造函数 <code>Person</code> 的实例，所以 <code>p</code> 的原型就是 <code>Person.prototype</code> 。</p>
<h3 id="2-8-Reflect-apply-target-thisArg-args"><a href="#2-8-Reflect-apply-target-thisArg-args" class="headerlink" title="2.8 Reflect.apply(target, thisArg, args)"></a>2.8 Reflect.apply(target, thisArg, args)</h3><p>该方法替代类似 Function.prototype.apply() 这样的方法，用于改变函数调用的作用域。</p>
<p>在之前，如果要获取一个数组中的最大数或最小数，可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2.6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">-10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr)); <span class="comment">// -10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min.call(<span class="built_in">Math</span>, ...arr)); <span class="comment">// -10</span></span><br></pre></td></tr></table></figure>
<p>但由于最后一个使用了 <code>call</code> 调用，所以这里使用扩展符 <code>...</code>，将数组的项逐个列出，以参数的形式传递给函数。</p>
<p>现在，应用 <code>Reflect.apply</code> 方法也能达到相同的目的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2.6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">-10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.floor, <span class="built_in">Math</span>, arr)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.max, <span class="built_in">Math</span>, arr)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.min, <span class="built_in">Math</span>, arr)); <span class="comment">// -10</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个是对数组 <code>arr</code> 的第一项进行向下取整。后面两个分别是取数组的最大值和最小值。</p>
<h3 id="2-9-Reflect-construct-target-args-newTarget"><a href="#2-9-Reflect-construct-target-args-newTarget" class="headerlink" title="2.9 Reflect.construct(target, args[, newTarget])"></a>2.9 Reflect.construct(target, args[, newTarget])</h3><p>该方法替代类似 new target(…args) 这样的方法，用于构造函数进行 new 操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'yix'</span>),</span><br><span class="line">    p2 = <span class="built_in">Reflect</span>.construct(Person, [<span class="string">'yix'</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1988, 10, 10'</span>),</span><br><span class="line">    date2 = <span class="built_in">Reflect</span>.construct(<span class="built_in">Date</span>, [<span class="number">1988</span>, <span class="number">10</span>, <span class="number">10</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(date1); <span class="comment">// Mon Oct 10 1988 08:00:00 GMT+0800</span></span><br><span class="line"><span class="built_in">console</span>.log(date2); <span class="comment">// Thu Nov 10 1988 00:00:00 GMT+0800</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>p1</code> 和 <code>p2</code> 都是构造函数 <code>Person</code> 的实例，它们都有相同属性和方法。然后，我们分别用 <code>new Date</code> 和 <code>Reflect.construct</code> 创建了一个时间对象，但不知为何，后者的月份竟然多了 1 。</p>
<h3 id="2-10-Reflect-ownKeys-target"><a href="#2-10-Reflect-ownKeys-target" class="headerlink" title="2.10 Reflect.ownKeys(target)"></a>2.10 Reflect.ownKeys(target)</h3><p>该方法替代类似 Object.getOwnPropertyNames() 与 Object.getOwnPropertySymbols() 这样的方法，用于返回目标对象的属性键组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    job: <span class="string">'web'</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.for(<span class="string">'name'</span>)]: <span class="string">'cyclone'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(person)); <span class="comment">// ["name", "job", Symbol(name)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(&#123;&#125;)); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h3 id="2-11-Reflect-getOwnPropertyDescriptor-target-key"><a href="#2-11-Reflect-getOwnPropertyDescriptor-target-key" class="headerlink" title="2.11 Reflect.getOwnPropertyDescriptor(target, key)"></a>2.11 Reflect.getOwnPropertyDescriptor(target, key)</h3><p>该方法替代类似 Object.getOwnPropertyDescriptor() 这样的方法，用于返回目标对象的指定属性的描述符，如果属性不存在，则返回 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    job: <span class="string">'web'</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.for(<span class="string">'name'</span>)]: <span class="string">'cyclone'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>)); </span><br><span class="line"><span class="comment">// &#123;value: "yix", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.getOwnPropertyDescriptor(person, <span class="string">'age'</span>)); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.getOwnPropertyDescriptor([], <span class="string">'length'</span>)); </span><br><span class="line"><span class="comment">// &#123;value: 0, writable: true, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-12-Reflect-isExtensible-target"><a href="#2-12-Reflect-isExtensible-target" class="headerlink" title="2.12 Reflect.isExtensible(target)"></a>2.12 Reflect.isExtensible(target)</h3><p>该方法替代类似 Object.isExtensible() 这样的方法，用于判断一个对象是否是可扩展的，返回一个布尔值，表示可否扩展。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.isExtensible(person)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'yix'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "yix"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冻结对象</span></span><br><span class="line"><span class="built_in">Object</span>.freeze(person);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.isExtensible(person)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">person.job = <span class="string">'web'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "yix"&#125;</span></span><br></pre></td></tr></table></figure>
<p>一开始，<code>person</code> 对象是可以扩展的，所以，我们可以在该对象上添加 <code>name</code> 属性。当冻结它后，该对象便不能扩展了，因此，添加 <code>job</code> 属性也不成功。</p>
<h3 id="2-13-Reflect-preventExtensions-target"><a href="#2-13-Reflect-preventExtensions-target" class="headerlink" title="2.13 Reflect.preventExtensions(target)"></a>2.13 Reflect.preventExtensions(target)</h3><p>该方法替代类似 Object.preventExtensions() 这样的方法，用于阻止对象的扩展（即不能添加新属性）。返回一个布尔值，表示对象的不可扩展性是否设置成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.isExtensible(person)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'yix'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "yix"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让对象不可扩展</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.preventExtensions(person)); <span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line">person.job = <span class="string">'web'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "yix"&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，同样是将 <code>person</code> 对象由可扩展变为不可扩展。</p>
<p>总得来说，Proxy 和 Reflect 这两个API都是 ES6 针对JavaScript的设计缺陷而引入的。在JavaScript底层操作方面，它们给开发者提供了更多的可能。Proxy 主要是拦截或重新定义原有方法的默认行为，而 Reflect 则更倾向于原有方法的封装和完善。</p>

  </div>

</div>

  <div class="footer">
    <a href="http://www.yi-jy.com">前端技术空间--易建勇</a> /
    <a href="http://www.beianbeian.com/search/yi-jy.com">Copyright © 2012-2018</a> /
    <a href="https://github.com/joy-yi0905/hexo-theme-record">Record</a> /
    <a href="http://yi-jy.com/atom.xml">Rss</a>
  </div>

</div>

</body>


    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7d5550c80ba3b42cfa5323fc0e92699f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


</html>