<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/>

  
  <meta name="author" content="易建勇,YI_joy">
  

  
  <meta name="description" content="ES6-iterators-generators | 前端技术空间">
  

  
  <meta name="keywords" content="es6 iterators迭代器 generators函数">
  

  

  <title>ES6中iterators与generators | 前端技术空间</title>

  <link rel="stylesheet" href="/css/blog.css">
</head>
<body>

<div class="blog">

<div class="navigation">
  <ul class="nav-list">
    
      <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
    
      <li class="nav-item"><a class="nav-link" href="/archives">Archives</a></li>
    
  </ul>
</div>

<div class="post">

  <h1 class="post-title">ES6中iterators与generators</h1>

  <time class="post-time">2016-07-05</time>

  <div class="post-content">
    <p>要遍历处理一些数据，我们一般会用到 for 或者 for in 循环，但它们存在着一些缺点，比如，对于变量值大于循环值时，for 会出错。</p>
<p>另外，对于一些类似数组对象的处理，我们又不能直接采用数组的方法，需要进行格式转换，处理完后，又需要再转换成原来的格式，这样操作起来非常的繁琐。</p>
<p>针对这些问题，ES6 引入了 iterators 和 generators 。<a id="more"></a></p>
<h2 id="一、Iterators"><a href="#一、Iterators" class="headerlink" title="一、Iterators"></a>一、Iterators</h2><p>Iterator 简称 迭代器，它为 ES 中不同类型的数据集合提供了一种访问机制。也就是说，只要数据结构具有 Iterator 接口，便可以对该数据进行遍历操作。</p>
<p>其实判断是否具有 Iterator 接口，主要是看数据结构是否原生就具有 Symbol.iterator 属性，这个属性也被表示为 默认的迭代器。</p>
<p>我们所熟知的 数组 就天生具备这个特性。</p>
<h3 id="1-1-访问默认迭代器"><a href="#1-1-访问默认迭代器" class="headerlink" title="1.1 访问默认迭代器"></a>1.1 访问默认迭代器</h3><p>你可以使用 Symbol.iterator 访问对象的默认迭代器，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>
<p>上面的代码访问了 values 的默认迭代器，并且使用迭代器对象下的 <code>next()</code>，来迭代了数组的每一项。</p>
<p>因为 Symbol.iterator 被指定为 默认迭代器，那么你可以用它来判断一个对象是否可迭代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello"</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>())); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>())); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>代码中的 isIterable() 函数用于检测对象是否存在默认迭代器，同时也判断了它是否为 函数。</p>
<h3 id="1-2-for…of"><a href="#1-2-for…of" class="headerlink" title="1.2 for…of"></a>1.2 for…of</h3><p>除了上面的 <code>next()</code> 方法，我们还可以对具有 Symbol.iterator 属性的数据集合使用 <code>for...of</code>，它可以遍历数组、Set、Map、字符串以及节点列表等类似数组的对象。</p>
<h4 id="1-2-1-遍历-数组、Set、Map"><a href="#1-2-1-遍历-数组、Set、Map" class="headerlink" title="1.2.1 遍历 数组、Set、Map"></a>1.2.1 遍历 数组、Set、Map</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'yix'</span>);</span><br><span class="line">map.set(<span class="string">'job'</span>, <span class="string">'web'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> str <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> num <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["name", "yix"]</span></span><br><span class="line"><span class="comment">// ["job", "web"]</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-遍历-字符串"><a href="#1-2-2-遍历-字符串" class="headerlink" title="1.2.2 遍历 字符串"></a>1.2.2 遍历 字符串</h3><p>有的时候，字符串中可能包含 双字节 字符，如果用传统的 for 循环，可能无法精确获取对应位置的字符，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"A 𠮷 B"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// 空格</span></span><br><span class="line"><span class="comment">// �</span></span><br><span class="line"><span class="comment">// �</span></span><br><span class="line"><span class="comment">// 空格</span></span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，预期输出的值，应该为 <code>A 空格 𠮷 空格 B</code>，而实际结果确实 <code>𠮷</code> 字符被两个乱码所替代。</p>
<p>但如果使用 <code>for...of</code> 就不会出现这样的问题了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"A 𠮷 B"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// 空格</span></span><br><span class="line"><span class="comment">// 𠮷 </span></span><br><span class="line"><span class="comment">// 空格</span></span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-遍历-节点列表-NodeList"><a href="#1-2-3-遍历-节点列表-NodeList" class="headerlink" title="1.2.3 遍历 节点列表 NodeList"></a>1.2.3 遍历 节点列表 NodeList</h3><p>要操作 DOM 元素，我们通常会使用 <code>document.querySelectorAll()</code> 或者 <code>document.getElementsByTagName(&quot;div&quot;)</code> 这些原生方法来获取 DOM对象，而它们返回的 DOM对象 又是一个类似数组的 NodeList 对象，这个对象也具有 Symbol.iterator 属性，因此，我们可以直接对该对象使用 <code>for...of</code> 操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> div <span class="keyword">of</span> divs) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(div.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中，调用 getElementsByTagName() 去获取文档中所有 div 的 NodeList 集合，然后使用 for-of 循环输出其对应的 id，这样我们就无需先把转换为数组，再做类似的处理了。</p>
<h3 id="1-2-4-迭代对象的一些方法"><a href="#1-2-4-迭代对象的一些方法" class="headerlink" title="1.2.4 迭代对象的一些方法"></a>1.2.4 迭代对象的一些方法</h3><p>对于可迭代的数据集合，ES6提供了三个方法：</p>
<ul>
<li>entries() 返回一个包含键值对的迭代器</li>
<li>values() 返回一个包含值的迭代器</li>
<li>keys() 返回一个包含键的迭代器</li>
</ul>
<p>你可以通过这其中的任何一种方法，来迭代检索集合中的每一项。下面对其逐一介绍：</p>
<h4 id="entries-方法"><a href="#entries-方法" class="headerlink" title="entries() 方法"></a>entries() 方法</h4><p>不同的数据类型，该方法返回的值不同，它的值是一个包含两项的数组。对于数组，第一项是数字索引。对于sets，第一项是值（因为它的键值是相同的）。对于 maps，它的第一项是键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'yix'</span>);</span><br><span class="line">map.set(<span class="string">'job'</span>, <span class="string">'web'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> str <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, "a"]</span></span><br><span class="line"><span class="comment">// [1, "b"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> num <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 1]</span></span><br><span class="line"><span class="comment">// [2, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["name", "yix"]</span></span><br><span class="line"><span class="comment">// ["job", "web"]</span></span><br></pre></td></tr></table></figure>
<h4 id="values-方法"><a href="#values-方法" class="headerlink" title="values() 方法"></a>values() 方法</h4><p>这个方法只是返回集合中存储的值，但是 数组 不具备该方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'yix'</span>);</span><br><span class="line">map.set(<span class="string">'job'</span>, <span class="string">'web'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> num <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yix</span></span><br><span class="line"><span class="comment">// web</span></span><br></pre></td></tr></table></figure>
<h4 id="keys-方法"><a href="#keys-方法" class="headerlink" title="keys() 方法"></a>keys() 方法</h4><p>该方法返回集合中的每一个键，对于数组，它只是返回 数字索引。对于 sets，因为它的 键 和 值是相同的，所以keys() 和 values() 将返回相同的内容。对于 maps，keys() 将返回独一无二的键，用代码来证实下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'yix'</span>);</span><br><span class="line">map.set(<span class="string">'job'</span>, <span class="string">'web'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> str <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> num <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="comment">// job</span></span><br></pre></td></tr></table></figure>
<h2 id="二、Generators"><a href="#二、Generators" class="headerlink" title="二、Generators"></a>二、Generators</h2><h3 id="2-1-Generator函数"><a href="#2-1-Generator函数" class="headerlink" title="2.1 Generator函数"></a>2.1 Generator函数</h3><p>Generator函数是 ES6 中新引入的一种特殊函数，但它与普通的函数有些不同。在函数定义的写法上，它在关键词 function 后面增加了一个 <code>*</code> 符号，并且在函数体内，可以使用新的关键词 <code>yield</code>。</p>
<p>该函数返回一个迭代器对象。来看一个最基本的 Generator函数 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greet = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> greet;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bbb'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'generator'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>*</code> 符号前后是否有空格不会影响 Generator函数 的定义。</p>
<p>通常情况下，要使用定义后的函数，可以通过函数调用的形式，但是对于 Generator函数，因为函数本身只是返回一个迭代器对象，所以你必须先调用它，然后再用这个迭代器对象的 <code>next()</code> 方法才能执行 Generator函数 中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greet = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> greet;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bbb'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'generator'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hi = hello(); <span class="comment">// 'aaa'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hi.next()); <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hi.next()); <span class="comment">// 'bbb' &#123;value: "generator", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hi.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>让我们来分析下上面的代码，首先利用变量 hi 来保存 hello函数返回的迭代器对象，首次输出 aaa，到第一个 yield 时结束。</p>
<p>当第一次调用 <code>hi.next()</code> 时，则执行第一个 yield，接着输出一个对象，该对象包含了两个属性，<code>value</code> 和 <code>done</code>。<code>value</code> 的值表示 yield 后面跟着的内容，而 <code>done</code> 则表示迭代还没结束。</p>
<p>当第二次调用 <code>hi.next()</code> 时，则执行第一个 yield 后面的语句，并且执行第二个 yield 的内容，直到遇到下一个 yield 后，便结束运行。此时，是先输出 bbb，然后输出的对象中的 <code>value</code> 是第二个 yield 后面的值，因为迭代还没结束，所以 <code>done</code> 的值仍然为 false 。</p>
<p>当第三次调用 <code>hi.next()</code> 时，因为函数中没有剩余的 yield 和 其他可执行的代码，所以返回的对象中 <code>value</code> 的值为 undefined, 并且 <code>done</code> 的值变为 true 了。</p>
<p>要注意的是，如果关键词 yield 后面没有任何内容，则 <code>value</code> 的值为 undefined ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hi = hello();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hi.next()); <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hi.next()); <span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hi.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-yield"><a href="#2-2-yield" class="headerlink" title="2.2 yield"></a>2.2 yield</h3><p>作为 ES6 中一个新的关键词，yield 语句只能在 Generator函数 中使用。倘若你把它用在普通函数中，则会抛出一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hi = hello(); <span class="comment">// 报错：Unexpected string</span></span><br></pre></td></tr></table></figure>
<p>通过前面讲到的 Generator函数 以及它的运行原理，我们可以知道，yield 语句可以分段执行 Generator函数 中的代码。只有当执行 <code>next()</code> 方法时，才能逐个运行 yield 语句。然后逐个返回对应的值，这一点和 return 的用法相同，但是它们之间也有差异。</p>
<h4 id="yield-与-return-的异同比较"><a href="#yield-与-return-的异同比较" class="headerlink" title="yield 与 return 的异同比较"></a>yield 与 return 的异同比较</h4><ul>
<li>一个函数中可以有多个 yield 语句，但只能有一个 return 语句，即可执行多次和一次的区别</li>
<li>yield 具有暂停执行函数内代码的功能，并且能够记录上一次暂停的位置，直到再次执行 next() 方法，而 return 没有这些</li>
<li>yield 只能在 Generator函数 中使用，而 return 既可以使用在普通函数，也能使用在 Generator函数</li>
<li>yield 和 return 都能返回其后面的值</li>
</ul>
<h3 id="2-3-Generator函数-返回对象的方法-next"><a href="#2-3-Generator函数-返回对象的方法-next" class="headerlink" title="2.3 Generator函数 返回对象的方法 - next()"></a>2.3 Generator函数 返回对象的方法 - next()</h3><p>其实在上面的文章，我们已经有了很多关于 <code>next()</code> 的描述。 主要是通过调用 <code>next()</code>，来执行一个接一个的执行 yield 语句。</p>
<p>这里要特别增加说明的是，带参数的 <code>next()</code>，我们来看下的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> a + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> b + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total = sum();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(total.next(<span class="number">5</span>)); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(total.next(<span class="number">5</span>)); <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(total.next(<span class="number">5</span>)); <span class="comment">// &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(total.next(<span class="number">5</span>)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<p>如上面代码，与之前的 <code>next()</code> 调用不同的是，在这段代码中，我们每次调用 <code>next()</code> 时，都给它传递一个数字 5 作为参数。</p>
<p>第一次执行 <code>next(5)</code>，返回的 <code>value</code> 的值为 2。即 <code>b = yield 2</code> 运行的结果。</p>
<p>第二次执行 <code>next(5)</code>，返回的 <code>value</code> 的值为 4。即 <code>yield a + 3</code> 运行的结果。</p>
<p>第三次执行 <code>next(5)</code>，返回的 <code>value</code> 的值为 8。这个结果有点出乎我们所料，此时执行的是 <code>yield b + 3</code>，而 b 的值是 <code>yield 2</code>，按理来说应该是 2 + 3 等于 5 才对。但是，由于 <code>next()</code> 方法传递了参数 5，此时上一个 yield 的值被这个参数所覆盖，所以才出现 5 + 3 等于 8 这样的结果 。</p>
<p>第四次执行 <code>next(5)</code>，返回的 <code>value</code> 的值为 1。即 <code>yield 1</code> 运行的结果。</p>
<p>综上所述，<code>next()</code> 方法传递参数只会影响那些有 yield 参与操作的 yield 语句。</p>
<h3 id="2-4-Generator函数-返回对象的方法-return"><a href="#2-4-Generator函数-返回对象的方法-return" class="headerlink" title="2.4 Generator函数 返回对象的方法 - return()"></a>2.4 Generator函数 返回对象的方法 - return()</h3><p>除了上面说的 <code>next()</code>，Generator函数 返回的对象中还有 <code>return()</code> 方法，该方法返回一个特定的值，并且结束迭代当前 Generator函数 中的 yield 语句。</p>
<p>来看个相关的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greet = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> greet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'generator'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hi = hello(); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hi.next()); <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hi.return()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hi.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>第一次调用 <code>next()</code>，正常返回对应的对象。</p>
<p>接着调用 <code>return()</code>，此时返回的对象中 value 属性值为 undefined，done 属性值则为 true，即表示停止迭代了。</p>
<p>当后面再次调用 <code>next()</code>，后面返回的对象都是 <code>{value: undefined, done: true}</code> 了。</p>
<p>和 <code>next()</code> 类似，<code>return()</code> 函数也可以接收一个参数，此时，调用该方法后，返回的对象中 value 的属性值就是该参数，而其他的基本不变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greet = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> greet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'generator'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hi = hello(); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hi.next()); <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hi.return(<span class="string">'abc'</span>)); <span class="comment">// &#123;value: "abc", done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hi.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-Generator函数-返回对象的方法-throw"><a href="#2-5-Generator函数-返回对象的方法-throw" class="headerlink" title="2.5 Generator函数 返回对象的方法 - throw()"></a>2.5 Generator函数 返回对象的方法 - throw()</h3><p>最后，Generator函数 返回的对象中还有一个 <code>throw()</code> 方法。</p>
<p>在 JavaScript 中，<code>throw()</code> 方法通常与 try…catch 结合使用，主要用于当程序运行出错时，我们可以自定义一个错误对象，然后向控制台抛出一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = prompt(<span class="string">'输入一个 0 到 10 之间的数'</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (number &gt; <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'errBig'</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"errSmall"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="keyword">if</span>(e === <span class="string">'errBig'</span>)</span><br><span class="line">    alert(<span class="string">'错误! 这个值太大'</span>);</span><br><span class="line">  <span class="keyword">if</span>(e ===<span class="string">'errSmall'</span>)</span><br><span class="line">    alert(<span class="string">'错误! 这个值太小'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码检测用户输入的值，然后根据值的大小来定义不同的错误，最后反馈对应的错误。</p>
<p>以下代码演示了 Generator函数 返回对象中 <code>throw()</code> 方法的用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">error</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err = error(); </span><br><span class="line">err.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    err.throw(<span class="string">'abc'</span>);</span><br><span class="line">    err.throw(<span class="string">'def'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部捕获 abc</span></span><br><span class="line"><span class="comment">// 外部捕获 def</span></span><br></pre></td></tr></table></figure>
<p>运行 <code>err.throw(&#39;abc&#39;)</code> 时，错误在 Generator函数 内部被捕获。当再次运行 <code>err.throw(&#39;def&#39;)</code>，错误被函数外部的 catch 所捕获。</p>
<h3 id="2-6-Generator函数-作为-对象方法"><a href="#2-6-Generator函数-作为-对象方法" class="headerlink" title="2.6 Generator函数 作为 对象方法"></a>2.6 Generator函数 作为 对象方法</h3><p>要将 Generator函数 定义成 对象中的方法，可采用如下写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    showName: <span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = person.showName();</span><br><span class="line"></span><br><span class="line">getName.next(); <span class="comment">// "yix"</span></span><br></pre></td></tr></table></figure>
<p>通过前面的 对象 章节，我们知道，在对象字面量中定义方法可以采用缩写形式，于是，person 中的 showName 可以这样改写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    * showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上两段定义 person 对象的代码是等价的。</p>
<h3 id="2-7-Generator函数-与-异步操作"><a href="#2-7-Generator函数-与-异步操作" class="headerlink" title="2.7 Generator函数 与 异步操作"></a>2.7 Generator函数 与 异步操作</h3><p>利用 Generator函数 中的 yield，我们可以很方便的处理一些异步操作，而无需使用一层或多层回调函数，如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">paint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">yield</span> getData(<span class="string">'data.json'</span>),</span><br><span class="line">        data = formatData(resp);</span><br><span class="line"></span><br><span class="line">    insertHtml(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> render = paint();</span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">render.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化数据 并 插入数据</span></span><br><span class="line">render.next();</span><br></pre></td></tr></table></figure>
<p>上面的代码，定义了一个 <code>paint</code> 这个 Generator函数，在这个函数中，getData函数通过类似ajax的方式获取到数据。<code>render = paint()</code> 这行表示将返回的遍历器赋值给 render，当调用 <code>render.next()</code> 时，将会获取到数据，并将返回的数据赋值给了 resp。然后我们接着调用 <code>render.next()</code>，此时，便会执行 Generator函数 中其余的代码。</p>
<p>试想下，如果你需要的数据需要通过多个ajax才能拿到，那你肯定少不了层层嵌套的回调函数。但使用 yield 来编写，则显得非常的直观和简洁。</p>

  </div>

</div>

  <div class="footer">
    <a href="http://www.yi-jy.com">前端技术空间--易建勇</a> /
    <a href="http://www.beianbeian.com/search/yi-jy.com">Copyright © 2012-2018</a> /
    <a href="https://github.com/joy-yi0905/hexo-theme-record">Record</a> /
    <a href="http://yi-jy.com/atom.xml">Rss</a>
  </div>

</div>

</body>


    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7d5550c80ba3b42cfa5323fc0e92699f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


</html>