<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/>

  
  <meta name="author" content="易建勇,YI_joy">
  

  
  <meta name="description" content="ES6-promise | 前端技术空间">
  

  
  <meta name="keywords" content="es6 promise">
  

  

  <title>ES6中的 Promise | 前端技术空间</title>

  <link rel="stylesheet" href="/css/blog.css">
</head>
<body>

<div class="blog">

<div class="navigation">
  <ul class="nav-list">
    
      <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
    
      <li class="nav-item"><a class="nav-link" href="/archives">Archives</a></li>
    
  </ul>
</div>

<div class="post">

  <h1 class="post-title">ES6中的 Promise</h1>

  <time class="post-time">2016-07-20</time>

  <div class="post-content">
    <p>我们都知道，javascript 是一种单线程编程语言，这意味着它在同一个时间，只能一次运行一段代码。当需要完成多个工作任务时，那么 javascript 引擎会将这些任务逐个排序，只有当完成前一个任务项时，才能继续执行下一个任务项，依次进行下去，直到最后一个任务。</p>
<p>javascript 的这种执行模式也被称为 <strong>同步模式（sync）</strong>。这种模式的特点是运行时间长、容易出现阻塞程序卡死、后续任务必须等待。<a id="more"></a></p>
<p>同步模式 最常见的表现形式是刷新页面。即当用户刷新页面后，客户端发送请求或处理事件期间，用户必须等待，此时浏览器可能会无响应或者假死，而且其他任务也必须排队执行。</p>
<p>与 同步模式（sync）相对应的是 <strong>异步模式（async）</strong>。这种模式的特点是运行时间短、多任务同时执行、提高服务器性能。</p>
<p>异步模式 最常见的表现形式是 ajax 请求。即当用户发送ajax请求或处理事件期间，用户可以去做其他事或程序可以执行其他任务，等到请求返回或事件完毕后，通过回调函数的方式再执行相应的操作。</p>
<p>可以看到，对于一些复杂的软件开发，异步模式编程 尤为重要。</p>
<p>在 ES6 之前，常见的异步操作方式主要有三种，即 事件驱动、回调函数、异步操作库。</p>
<h4 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h4><p>所谓的事件驱动，也就是通过用户的操作，来触发某些事件的执行、或发送某些请求，类似按需加载。比如说，你在按钮 button 上添加了一个事件，事件的内容是弹出 button 自身的值。那么，只有当你点击 button 后，弹出按钮的值这个事件才会被添加到 工作队列 中，然后执行它。来看下相关代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种操作方式意图很明确，从事件本身来说比较简单，适用些基本的交互。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>在异步编程中，回调函数最值得一说的表现形式就是 ajax 请求，我们通常会在回调函数中处理由ajax请求回来的数据。</p>
<p>假设这里的例子使用 jquery 中 ajax 的请求方式，请求的数据文件为 data.txt，它的内容是 “我是ajax请求会的内容”，那么代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(<span class="string">'data.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'不用等ajax操作'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// "不用等ajax操作"</span></span><br><span class="line"><span class="comment">// "我是ajax请求会的内容"</span></span><br></pre></td></tr></table></figure>
<p>另外，javascript 提供的定时器方法（setTimeout、setInterval）也能用于 异步编程，即只有当到了某个时间段后，回调函数的内容才会被添加到 工作队列中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1s后输出'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'不用等延时操作'</span>);</span><br></pre></td></tr></table></figure>
<p>回调函数也存在一些问题，比如说，如果各个请求之间存在依赖关系，即后一个请求需要使用前一个请求的结果，或者需要前前一个的请求结果，这样你就得嵌套层层回调，此时便会出现回调地狱：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(<span class="string">'data1.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data1 = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    $.ajax(<span class="string">'data2.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data2 = data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        $.ajax(<span class="string">'data3.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data3 = data;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">             $.ajax(<span class="string">'data4.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> data4 = data;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样代码变得很难调试，不能捕获到错误，并且代码层面看上去也不容易理解。</p>
<h4 id="异步操作库"><a href="#异步操作库" class="headerlink" title="异步操作库"></a>异步操作库</h4><p>上面说的两种形式都是基于原生javascript，如果需求较复杂，可能实现起来那就没那么容易。于是 javascript 开源社区出现了一些异步操作的库，比较出名的有 jquery 中的 deferred、promise.js、queue.js 等。</p>
<p>其实，无论是使用上面提到的哪种方式，它们都会存在这样或者那样的问题。接下来，我们来看看 ES6 引入的 promise。</p>
<h2 id="一、Promise-的创建以及状态"><a href="#一、Promise-的创建以及状态" class="headerlink" title="一、Promise 的创建以及状态"></a>一、Promise 的创建以及状态</h2><p>我们可以通过 Promise 的构造函数来新创建一个 Promise，这个新创建的 Promise 不会立马运行其中的代码，它只是异步操作的占位符，用于在未来的某个时刻触发，或者永远也不触发(出现错误时)。</p>
<p>先来看下它的基本语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure>
<p>Promise 的构造函数接受一个参数，这个参数也被称为 执行器（executor），它是一个函数。该函数包含了初始化 Promise 的相关代码，并且该执行器函数也有两个参数，即：<code>resolve</code> 和 <code>reject</code></p>
<p>讲这两个参数之前，我们先来说说 Promise 的三个不同状态，它们分别如下：</p>
<ul>
<li>pending：Promise 的初始状态</li>
<li>fulfilled：异步操作成功的状态</li>
<li>rejected：异步操作失败、错误等状态</li>
</ul>
<p>新创建的 Promise 是处于 <code>pending</code> 这样一个初始状态，它被认为是 unsettled（未完成）的。</p>
<p>当进行异步操作后，Promise 状态就由初始状态转变成后面两种状态的一种。这个时候，它则被认为是 settled（已完成）的。</p>
<p>Promise 并没有提供相关的属性或者方法用于获取这些状态值，它只是给了我们对于 Promise 中异步操作后状态发生改变的一个感性认识。</p>
<p>这样，我们就可以知道当前 Promise 异步操作后，是哪个状态，后续会进入怎样的操作。</p>
<p>我们用代码来量化下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步操作出错</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步操作成功</span></span><br><span class="line">    resolve(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，我们回到之前 执行器 的两个参数：<code>resolve</code> 和 <code>reject</code>。当 Promise 进行异步操作时，如果出现错误，那么就相当于由 <code>pending</code> 状态进入 <code>rejected</code> 状态。此时，执行器 中就会调用 <code>reject()</code> 这个函数，并将一个错误对象以参数的形式传递给该函数。</p>
<p>倘若 Promise 异步操作成功，那么就相当于由 <code>pending</code> 状态进入 <code>fulfilled</code> 状态 。此时，执行器 中就会调用 <code>resolve()</code> 这个方法，并将异步操作的结果以参数的形式传递给该函数。</p>
<h2 id="二、Promise-原型方法"><a href="#二、Promise-原型方法" class="headerlink" title="二、Promise 原型方法"></a>二、Promise 原型方法</h2><p>在了解了 Promise 的相关状态和函数后，我们再来看看 Promise 的原型上有两个方法，即：<code>then()</code> 和 <code>catch()</code> 。</p>
<p>为了节省篇幅以及代码量，我们首先把一个ajax请求封装成一个 Promise，并它赋值给名为 <code>getData</code> 的变量，文章后面提到的 <code>getData</code> 都是此处定义的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getData = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">'data.txt'</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-Promise-prototype-then"><a href="#2-1-Promise-prototype-then" class="headerlink" title="2.1 Promise.prototype.then()"></a>2.1 Promise.prototype.then()</h3><p>当 Promise 异步操作完，状态改变后，我们可以通过 <code>then()</code> 方法为 Promise 添加对应的回调函数。它的基本语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
<p>该方法返回一个新的 Promise 对象，正因为如此，Promise 也可以采用链式调用的写法。</p>
<p>同时，该方法还可以接收两个参数，第一个为必选，表示 fulfilled 状态下的回调函数。而第二个参数为可选，表示 rejected 状态下的回调函数。</p>
<p>当传递两个参数，则表示同时指定已成功完成和错误的回调函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fulfilled or Rejected</span></span><br><span class="line">getData.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然，你可以只传递一个参数，用于设定已成功完成的回调函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fulfilled</span></span><br><span class="line">getData.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>或者，你也可以通过下面的形式只指定错误回调函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rejected</span></span><br><span class="line">getData.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Promise-prototype-catch"><a href="#2-2-Promise-prototype-catch" class="headerlink" title="2.2 Promise.prototype.catch()"></a>2.2 Promise.prototype.catch()</h3><p>当 Promise 异步操作完，状态改变后，并且发生错误时，我们可以通过 <code>catch()</code> 方法为 Promise 添加的回调函数来捕获这个错误。它的基本语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch(onRejected)</span><br></pre></td></tr></table></figure>
<p>该方法返回一个新的 Promise 对象，正因为如此，Promise 也可以采用链式调用的写法。</p>
<p>同时，该方法还可以接收一个参数，表示 rejected 状态下的回调函数。下面的代码演示了错误的捕获：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "出错了！"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>它等价 then 的这种形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "出错了！"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如前面提到的，因为 <code>then()</code> 和 <code>catch()</code> 方法都是返回一个新的 Promise 对象，所以，我们可以使用链式调用的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "出错了！"</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'又出错了！'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "又出错了！"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同样的，之前的 <code>then()</code> 双参数写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getData.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>也可以改成链式调用的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getData.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>采用这种写法后，代码逻辑结构变得更清晰，并且如果前面的 <code>then()</code> 方法出错，那么后面的 <code>catch</code> 将捕获这个错误。</p>
<p>上面所介绍的内容，可以总结为 MDN 资料张的一张图：</p>
<img src="/2016/07/20/ES6-promise/promises.png" title="流程控制图">
<h2 id="三、Promise-实例方法"><a href="#三、Promise-实例方法" class="headerlink" title="三、Promise 实例方法"></a>三、Promise 实例方法</h2><p>讲完 Promise 的原型方法，我们再来说说他的实例方法。</p>
<h3 id="3-1-Promise-resolve"><a href="#3-1-Promise-resolve" class="headerlink" title="3.1 Promise.resolve()"></a>3.1 Promise.resolve()</h3><p><code>Promise.resolve()</code> 方法用于创建一个处于 <code>fulfilled</code> 状态的 Promise。来看下它的基本语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(value);</span><br></pre></td></tr></table></figure>
<p>以下两种写法等价：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">'abc'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> promise2 = <span class="built_in">Promise</span>.resolve(<span class="string">'abc'</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以通过回调函数 <code>then</code> 来获取它状态改变后的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="string">'abc'</span>);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// "abc"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果 <code>Promise.resolve()</code> 的参数是一个 Promise，此时返回的结果仍然是这个 Promse，不会对它做任何修改。代码验证如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promisePara = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">'012'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    promise = <span class="built_in">Promise</span>.resolve(promisePara);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise === promisePara);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// "012"</span></span><br></pre></td></tr></table></figure>
<p>如果传入到 <code>Promise.resolve()</code> 的参数是一个具有 <code>then</code> 方法的对象，那么这个对象被称为 <code>thenable</code> 对象，当调用 <code>Promise.resolve()</code> 时，会立即执行 <code>thenable</code> 对象中的 <code>then()</code> 方法，并且返回一个新的 Promise：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'The obj is thenable object!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(obj); <span class="comment">// "The obj is thenable object!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise); <span class="comment">// Promise &#123;[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined&#125;</span></span><br></pre></td></tr></table></figure>
<p>还有一种特殊情况，即 <code>Promise.resolve()</code> 不传入任何参数，此时，该函数就返回一个处于 <code>fulfilled</code> 状态的 Promise。 </p>
<h3 id="3-2-Promise-reject"><a href="#3-2-Promise-reject" class="headerlink" title="3.2 Promise.reject()"></a>3.2 Promise.reject()</h3><p><code>Promise.resolve()</code> 方法用于创建一个处于 <code>rejected</code> 状态的 Promise。来看下它的基本语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(reason);</span><br></pre></td></tr></table></figure>
<p>以下两种写法等价：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="string">'error!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> promise2 = <span class="built_in">Promise</span>.reject(<span class="string">'error!'</span>);</span><br></pre></td></tr></table></figure>
<p>与 <code>Promise.resolve()</code> 方法不同，如果只是调用 <code>Promise.reject()</code>，则会出现报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.reject(<span class="string">'error!'</span>); <span class="comment">// 错误：Uncaught (in promise) error!</span></span><br></pre></td></tr></table></figure>
<p>正确的做法是，需要在其后面添加回调函数 <code>catch()</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.reject(<span class="string">'error!'</span>);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error); <span class="comment">// "error!"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Promise-all"><a href="#3-3-Promise-all" class="headerlink" title="3.3 Promise.all()"></a>3.3 Promise.all()</h3><p>之前涉及到的方法都是处理单个 Promise 的，倘若要处理多个 Promise 实例，你可以使用 <code>Promise.all()</code> 方法，它的基本语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(iterable);</span><br></pre></td></tr></table></figure>
<p>该方法接收一个具有迭代属性的列表作为参数，表示需要监听的 Promise 列表，通常这个参数的数据类型是由多个 Promise 组成的数组。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="string">'a'</span>),</span><br><span class="line">    promise2 = <span class="built_in">Promise</span>.resolve(<span class="string">'b'</span>),</span><br><span class="line">    promise3 = <span class="built_in">Promise</span>.resolve(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise4 = <span class="built_in">Promise</span>.all([promise1, promise2, promise3]);</span><br></pre></td></tr></table></figure>
<p><code>Promise.all()</code> 返回的值，取决于它所监听的每个 Promise 中的状态函数。</p>
<p>如果 <code>Promise.all()</code> 所监听的 Promise 都处于 <code>fulfilled</code> 状态，即都进入了 <code>resolve</code> 函数，那么 <code>Promise.all()</code> 将返回一个新的、且处于 <code>fulfilled</code> 状态的 Promise 对象。 此时调用这个新的 Promise 对象的 <code>then()</code> 方法，那么被监听的 promise 所返回的值将组成一个数组，这个数组以参数的形式传递了 <code>then()</code> 方法。</p>
<p>有点晕，用代码来说明下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="string">'a'</span>),</span><br><span class="line">    promise2 = <span class="built_in">Promise</span>.resolve(<span class="string">'b'</span>),</span><br><span class="line">    promise3 = <span class="built_in">Promise</span>.resolve(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise4 = <span class="built_in">Promise</span>.all([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value), value);  <span class="comment">// true ["a", "b", "c"]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，因为被监听的 promise1、promise2、promise3 状态都变成了 <code>fulfilled</code>。于是，<code>Promise.all</code> 返回了一个处于 <code>fulfilled</code> 状态、名为 promise4 的新 Promise 对象。当调用 promise4 的 <code>then()</code> 方法时，promise1、promise2、promise3 所返回的值组成了一个数组，并且以参数的形式传递了 <code>then()</code> 方法，所以最后 value 的数据类型为数组，它的值是 [“a”, “b”, “c”] 。</p>
<p>如果 <code>Promise.all()</code> 所监听的 Promise 有一个处于 <code>rejected</code> 状态，即某一个进入了 <code>reject</code> 函数，那么 <code>Promise.all()</code> 会立即返回一个新的、且处于 <code>rejected</code> 状态的 Promise 对象。 此时调用这个新的 Promise 对象的 <code>then()</code> 方法，什么事也不会发生。而调用 <code>catch()</code> 方法，则它的参数是被监听的 Promise 列表中第一个 <code>rejected</code> 的 Promise 所返回的值。</p>
<p>老规矩，我们还是来看下代码吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="string">'a'</span>),</span><br><span class="line">    promise2 = <span class="built_in">Promise</span>.reject(<span class="string">'b'</span>),</span><br><span class="line">    promise3 = <span class="built_in">Promise</span>.reject(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise4 = <span class="built_in">Promise</span>.all([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value), value);  <span class="comment">// 不执行</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> error, error); <span class="comment">// string "b"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于 promise2 处于 <code>rejected</code> 状态，因此 promise4 中回调函数 <code>then()</code> 的参数是 promise2 的返回值。</p>
<h3 id="3-4-Promise-race"><a href="#3-4-Promise-race" class="headerlink" title="3.4 Promise.race()"></a>3.4 Promise.race()</h3><p><code>Promise.race()</code> 的用法和 <code>Promise.all()</code> 类似，都是用于处理一组 Promise 对象。它的基本语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race(iterable)</span><br></pre></td></tr></table></figure>
<p>它的参数也是需要监听的 Promise 列表，通常是一个由 Promise 组成的数组。</p>
<p>race 这个单词从字面上理解，有 比赛、赛跑的意思。或许你已经猜到了，<code>Promise.race()</code> 返回的结果取决于所监听的列表中最先改变状态的（无论是 fulfilled 还是 rejected） 的那个 Promise 。来段演示代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="string">'a'</span>),</span><br><span class="line">    promise2 = <span class="built_in">Promise</span>.reject(<span class="string">'b'</span>),</span><br><span class="line">    promise3 = <span class="built_in">Promise</span>.reject(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise4 = <span class="built_in">Promise</span>.race([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> value, value);  <span class="comment">// string "a"</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error); <span class="comment">// 不执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>或许这段代码说明不了什么，因为它们执行的顺序本来就是 promise1 -&gt; promise2 -&gt; promise3，当中没有任何延时操作。</p>
<p>再来看另外一段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">'a'</span>);</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">    promise2 =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(<span class="string">'a'</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">    promise3 = <span class="built_in">Promise</span>.reject(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise4 = <span class="built_in">Promise</span>.race([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> value, value);  <span class="comment">// 不执行</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> error, error); <span class="comment">// string "c"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，因为被监听的 Promise 列表改变状态的顺序依次为：promise3(Pending-&gt;Rejected)、 promise1(Pending-&gt;Fulfilled)、 promise2(Pending-&gt;Fulfilled)。因此，promise4 的回调函数取 promise3 返回的结果，即在 <code>catch()</code> 方法中输出 c 。</p>
<h2 id="四、Promise-链式应用"><a href="#四、Promise-链式应用" class="headerlink" title="四、Promise 链式应用"></a>四、Promise 链式应用</h2><p>通过链式调用的写法，我们在不同的 Promise 传递数据。</p>
<p>首先来看，如果传递的值是原始的数据类型，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promiseChain = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">256</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promiseChain.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 256</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(data);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(data);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 4</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，promiseChain 执行成功后，将在第一个 <code>then</code> 中返回 <code>Math.sqrt(data)</code>，它的结果为 16，然后第一个 <code>then</code> 将这个结果值以参数的形式，传递给第二个 <code>then</code>。接着，第二个 <code>then</code> 又返回 <code>Math.sqrt(data)</code>，它的结果是 4，然后第二个 <code>then</code> 又把这个结果值以参数的形式传递给第三个 <code>then</code> ，以此类推。</p>
<p>如果 Promise 中的 执行器 使用的是 <code>reject</code> 函数，那么通过 <code>catch</code> 方法，数据仍然会往下传递：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promiseChain = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">256</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promiseChain.catch(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 256</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(data);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(data);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 4</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>倘若传递的值是 Promise 对象，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promiseChain1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">256</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promiseChain2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">8</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promiseChain1.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 256</span></span><br><span class="line">    <span class="keyword">return</span> promiseChain2;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 8</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在不同 promiseChain1 执行成功后，在第一个 <code>then</code> 中返回了 promiseChain2，而 promiseChain2 已经处于 Resolved 状态，并通过 <code>resolve</code> 方法返回了 8，此时，便会把这个值以参数的形式传递给第二个 <code>then</code> 函数，并执行该函数。</p>
<p>如果 promiseChain2 执行器中使用的是 <code>reject</code> 函数，那么又会发生什么呢？来看下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promiseChain1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">256</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promiseChain2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">8</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promiseChain1.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 256</span></span><br><span class="line">    <span class="keyword">return</span> promiseChain2;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 出错，不会被调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>此时，第二个 <code>then</code> 将不会被调用。</p>
<p>若链式调用中返回 Promise 中存在 <code>reject</code> 方法，我们需要通过 <code>catch</code> 来传递数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promiseChain1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">256</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promiseChain2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">8</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promiseChain3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promiseChain1.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 256</span></span><br><span class="line">    <span class="keyword">return</span> promiseChain2;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> promiseChain3;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上就是 ES6 中 Promise 的相关内容，关于异步编程，听说 ES7 又推出了 <code>Async/Await</code> 方案，有时间再去一探究竟。</p>

  </div>

</div>

  <div class="footer">
    <a href="http://www.yi-jy.com">前端技术空间--易建勇</a> /
    <a href="http://www.beianbeian.com/search/yi-jy.com">Copyright © 2012-2018</a> /
    <a href="https://github.com/joy-yi0905/hexo-theme-record">Record</a> /
    <a href="http://yi-jy.com/atom.xml">Rss</a>
  </div>

</div>

</body>


    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7d5550c80ba3b42cfa5323fc0e92699f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


</html>