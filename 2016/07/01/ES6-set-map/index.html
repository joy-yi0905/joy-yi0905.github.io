<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/>

  
  <meta name="author" content="易建勇,YI_joy">
  

  
  <meta name="description" content="ES6-set-map | 前端技术空间">
  

  
  <meta name="keywords" content="es6 set map">
  

  

  <title>ES6中的 Set 与 Map | 前端技术空间</title>

  <link rel="stylesheet" href="/css/blog.css">
</head>
<body>

<div class="blog">

<div class="navigation">
  <ul class="nav-list">
    
      <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
    
      <li class="nav-item"><a class="nav-link" href="/archives">Archives</a></li>
    
  </ul>
</div>

<div class="post">

  <h1 class="post-title">ES6中的 Set 与 Map</h1>

  <time class="post-time">2016-07-01</time>

  <div class="post-content">
    <p>虽然数组是js中最常用的一种集合类数据类型，但它存在一些问题，比如说，它自身没有提出重复项的方法。</p>
<p>而说到对象，它有一个缺点是，属性名必须是字符串 或者 symbol 这样的数据类型。但我们有的时候，是需要将对象的键设置为像 数组、对象这样的数据类型。<a id="more"></a></p>
<p>针对这些问题，ES6 中引入 Set、WeakSet、Map、WeakMap 这四种数据结构。</p>
<h2 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h2><p>Set 是 ES6 中针对上述问题新增的第一种数据类型，它的组成项中没有重复的项，这样，我们就无需手动去重！</p>
<h3 id="1-1-创建-Set"><a href="#1-1-创建-Set" class="headerlink" title="1.1 创建 Set"></a>1.1 创建 Set</h3><p>要新建一个 Set ，可以通过 <code>new Set()</code> 这种实例方法进行创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>创建完成后，我们会发现它是类似对象的数据结构，里面没有任何组成项。</p>
<p>当然，你也可以像创建数组一样，使用<code>new Set()</code> 这个方法传入一个数组作为参数，用于实例化 Set 中的项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set &#123;1, 3, 5&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>通过上面的代码，我们便能看到 Set 中包含了三项。而要读取 Set 中项的个数，则可以使用 size 属性。</p>
<p>前面说过，Set 一个很重要的特点是不包含重复值，如果你像这样创建 Set，可能得不到你预期的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="string">'5'</span>, <span class="number">1</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set &#123;1, 3, 5, "5"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>你可能会觉得它能像数组一样，输出6个组成项。但由于 Set 不能有重复值的特性，所以代码中的 1 和 3 这些重复值分别只会保留一个。</p>
<p>不过要注意的是，在 Set 中不存在隐式转换，因此数字 5 和 字符串 ‘5’ 是两个不同的项。</p>
<h3 id="1-2-项的操作"><a href="#1-2-项的操作" class="headerlink" title="1.2 项的操作"></a>1.2 项的操作</h3><p>我们知道，数组中存在着操作数组项的各种方法，包括新增(push)，删除(pop)，清空(arr.length = 0)。而 Set 也不另外，它也有几乎类似的操作。</p>
<h4 id="1-2-1-增加项"><a href="#1-2-1-增加项" class="headerlink" title="1.2.1 增加项"></a>1.2.1 增加项</h4><p>你可以通过以下方法来新增 Set 项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">set.add(<span class="number">3</span>);</span><br><span class="line">set.add(<span class="string">'a'</span>);</span><br><span class="line">set.add(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set &#123;1, 3, "a"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">'b'</span>)); <span class="comment">// Set &#123;1, 3, "a", "b"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>从上面代码中可以看到，该方法返回 Set 本身。对于重复的项，<code>add()</code> 方法会直接忽略添加。</p>
<p>新增的项，不单单只能是基本的数据类型，它也可以为复杂的数据类型，比如数组，对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line">set.add([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set &#123;[1, 2], [1, 2], &#123;&#125;, &#123;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>但是，需要注意的是，因为数组或对象这样复杂的数据类型都是它们自身实例出来的 <code>对象</code> (new Array()、new Object()) ，所以 <code>{}</code> 和 <code>{}</code> 是两个不同的东西。  </p>
<p>另外，对于一些特殊值，在ES5中可能都是不对等的，但在 Set 中，则都被认为是同一个东西：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add(<span class="literal">true</span>);</span><br><span class="line">set.add(<span class="literal">false</span>);</span><br><span class="line">set.add(+<span class="number">0</span>);</span><br><span class="line">set.add(<span class="number">-0</span>);</span><br><span class="line">set.add(<span class="literal">NaN</span>);</span><br><span class="line">set.add(<span class="literal">NaN</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set &#123;true, false, 0, NaN&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-删除项"><a href="#1-2-2-删除项" class="headerlink" title="1.2.2 删除项"></a>1.2.2 删除项</h4><p>对于删除 Set 中的组成项，我们则可以通过 <code>delete()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">set.delete(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set &#123;1, 5&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set.delete(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.delete(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>该方法返回一个布尔值，如果删除的项存在，则返回 true，反之则返回 false。 </p>
<h4 id="1-2-3-清空项"><a href="#1-2-3-清空项" class="headerlink" title="1.2.3 清空项"></a>1.2.3 清空项</h4><p>假如一个 Set 中包含了很多项，我们需要快速清空它包含的项，则需要使用 <code>clear()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">set.clear();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-4-判断包含"><a href="#1-2-4-判断包含" class="headerlink" title="1.2.4 判断包含"></a>1.2.4 判断包含</h4><p>Set 提供了 <code>has()</code> 方法，它的作用是判断某个项是否存在于 Set  中，这对于我们查询对应的项无疑是非常方便的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">'a'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">3</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">0</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>该方法返回一个布尔值。</p>
<h3 id="1-3-Set-中的循环操作"><a href="#1-3-Set-中的循环操作" class="headerlink" title="1.3 Set 中的循环操作"></a>1.3 Set 中的循环操作</h3><p>读取 Set 中的每一项，最常见的方法是使用 <code>for of</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>当然，你也可以使用ES5中处理数组的 <code>forEach</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0 1</span></span><br><span class="line"><span class="comment">// 1 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">set.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index, value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1 1</span></span><br><span class="line"><span class="comment">// 3 3</span></span><br><span class="line"><span class="comment">// 5 5</span></span><br></pre></td></tr></table></figure>
<p>不过要注意，<code>forEach</code> 对于数组的操作，输出的 key 、val是“键值对”（索引、项的值）。但是 Set 则每次依次都是输出 相同的项。 </p>
<p>另外，Set 还提供了其他三个遍历方法，它们分别是：</p>
<ul>
<li>keys() : 返回键名的遍历器</li>
<li>values() : 返回键值的遍历器</li>
<li>entries() ： 返回键值对的遍历器 </li>
</ul>
<p>大体用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1, 1]</span></span><br><span class="line"><span class="comment">// [3, 3]</span></span><br></pre></td></tr></table></figure>
<p>目前为止，Set 中好像没有直接更新项的操作方法。所以，如果你要更新 Set 中的项，必须先把它们转换为数组，再转回 Set 。</p>
<h3 id="1-4-Set-与-数组的互转"><a href="#1-4-Set-与-数组的互转" class="headerlink" title="1.4 Set 与 数组的互转"></a>1.4 Set 与 数组的互转</h3><p>Set 和 数组有很多类似的特性，它们各自也有一些不同的方法。我们可以借助它们之间的方法和特性，来完成一些高效的操作。</p>
<p>比如，我们需要翻转 Set 中项的顺序时，可以先把它转换为数组，然后利用数组自身的 <code>reverse()</code> 方法即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">'a'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [...set]; <span class="comment">// 转换为数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr, arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// [1, 3, 5, "a"] true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.reverse())); <span class="comment">// Set &#123;"a", 5, 3, 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>又比如，当数组需要去重时，我们可以先将数组转换为 Set，然后再转回 数组。这样就避免了在数组中又循环，又判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">'a'</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr); <span class="comment">// 转换为 Set</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set, <span class="keyword">typeof</span> set); <span class="comment">// Set &#123;1, 3, 5, "a"&#125; object</span></span><br><span class="line"><span class="built_in">console</span>.log([...set]); <span class="comment">// [1, 3, 5, "a"]</span></span><br></pre></td></tr></table></figure>
<h2 id="二、WeakSet"><a href="#二、WeakSet" class="headerlink" title="二、WeakSet"></a>二、WeakSet</h2><p>WeakSet 是相对 Set 来说，从字面上理解是 弱的 Set 数据结构。它的用法与 Set 类似，不过也有几个不同的地方。</p>
<p>首先来说说 Set 的问题，假设有如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">    obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">set.add(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 清除引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...set][<span class="number">0</span>]); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>由上面的代码可以看到，虽然我们原始值设置为 <code>null</code>，以为这样就清除了原始引用，但最后还是打印出了其对应的值，这显然不是我们想要的目的。</p>
<p>类似地，有的时候我们会对一些DOM原始进行事件绑定，绑定完后就在内存中存在着一个引用关系。而如果事后，这些DOM可能会被移除，但引用关系仍然存在，这就造成了内存泄露，这当然不是你想看到的。</p>
<p>为了解决相关问题，ES6 中引入了 WeakSet，它只会以对象的形式进行弱引用，而这种弱引用不会影响垃圾回收机制。</p>
<p>然后是 WeakSet 有着和 Set 相同的方法，比如创建(new WeakSet)、新增项(add)、删除项(delete)、包含项判断(has)，但是没有 清空项(clear)的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> weakSet = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(),</span><br><span class="line">    obj = &#123;&#125;,</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">weakSet.add(obj);</span><br><span class="line">weakSet.add(arr);</span><br><span class="line"><span class="built_in">console</span>.log(weakSet); <span class="comment">// WeakSet &#123;&#123;&#125;, [1, 3]&#125;</span></span><br><span class="line"></span><br><span class="line">weakSet.delete(obj);</span><br><span class="line"><span class="built_in">console</span>.log(weakSet); <span class="comment">// WeakSet &#123;[1, 3]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(weakSet.has(obj)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(weakSet.has(arr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，WeakSet 创建函数的参数，只能是对象，而不能传递 基本数据类型，否者会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">    weakSet = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(arr); <span class="comment">// Invalid value used in weak set</span></span><br></pre></td></tr></table></figure>
<p>这里数组中的项是 1、3，它们都是基本数据类型。</p>
<p>你可以把它改为如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">3</span>], &#123;&#125;],</span><br><span class="line">    weakSet = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(weakSet); <span class="comment">// WeakSet &#123;[1, 3], &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>而对于 WeakSet 中项的操作，新增项函数也不能传递 基本数据类型，但 删除项 和 包含项判断 却没有这个要求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">3</span>], &#123;&#125;],</span><br><span class="line">    weakSet = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(weakSet); <span class="comment">// WeakSet &#123;[1, 3], &#123;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(weakSet.has(<span class="number">1</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(weakSet.delete(<span class="number">1</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">weakSet.add(<span class="number">1</span>); <span class="comment">// 报错： Invalid value used in weak set</span></span><br></pre></td></tr></table></figure>
<p>另外，WeakSet 还有一些其他与 Set 的不同地方：</p>
<ul>
<li>WeakSet 没有 <code>size</code> 属性，所以不能获取其中项的个数</li>
<li>WeakSet 中的项不能使用 <code>for-of</code> 循环，没有 <code>forEach()</code> 方法，所以不能读取到对应的项</li>
</ul>
<p>总之一句话，要处理一些弱引用关系时，可以尝试着使用 WeakSet 。</p>
<h2 id="三、Map"><a href="#三、Map" class="headerlink" title="三、Map"></a>三、Map</h2><p>前面说了很多关于 Set 的内容，但是你会发现，虽然我们可以对 Set 进行各种操作，但是我们无法改变其中的项，换言之，即不能更新 Set 中现有项的内容。</p>
<p>于是，ES6 中又引入了 Map。</p>
<h3 id="3-1-创建-Map"><a href="#3-1-创建-Map" class="headerlink" title="3.1 创建 Map"></a>3.1 创建 Map</h3><p>通过实例化方法 <code>new Map()</code> 来创建 Map：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>你也可以把一个数组作为参数传入到 <code>new Map()</code> 中，以下代码的结果同等上面的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([]); <span class="comment">// 传入一个空数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是，如果传入的数组中的项是非对象，则会抛出错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([&#123;&#125;, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// 错误：Iterator value 3 is not an entry object</span></span><br></pre></td></tr></table></figure>
<p>其实，说到底，Map 中就是一个键值对的集合。</p>
<p>如果 <code>new Map()</code> 传入的参数为数组，且数组项的值仍然为数组，当这个值(假设为 arrItem)的长度只有一项时，则 Map 项只有键，没有值(为 undefined)。当 arrItem 的长度为两项时，则 Map 项既有键，也有值。当 arrItem 的长度多余两项时，则 Map 项也是既有键，也有值，它们的值分别是 arrItem 中的第一项和第二项。有点晕？没关系，用代码来验证下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>], [<span class="number">2</span>]]),</span><br><span class="line">    map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'yix'</span>], [<span class="string">'age'</span>, <span class="number">28</span>], &#123;&#125;]),</span><br><span class="line">    map3 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'yix'</span>, <span class="string">'job'</span>, <span class="string">'web'</span>], [<span class="string">'age'</span>, <span class="number">28</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map1); <span class="comment">// Map &#123;1 =&gt; undefined, 2 =&gt; undefined&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map2); <span class="comment">// Map &#123;"name" =&gt; "yix", "age" =&gt; 28, undefined =&gt; undefined&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map3); <span class="comment">// Map &#123;"name" =&gt; "yix", "age" =&gt; 28&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-项的操作"><a href="#3-2-项的操作" class="headerlink" title="3.2 项的操作"></a>3.2 项的操作</h3><p>类似 Set，Map 中也有很多关于项操作的方法，比如说，项的新增、项的删除、清空以及判断包含等。</p>
<h4 id="3-2-1-增加项"><a href="#3-2-1-增加项" class="headerlink" title="3.2.1 增加项"></a>3.2.1 增加项</h4><p>前面我们知道，Set 是通过 <code>add()</code> 方法来新增项的，而 Map 中的操作则有点差异，它是利用 <code>set(key, value)</code> 的方法新增项的，该方法同时设置了项的值，并且，由于该方法执行后是返回自身，所以我们可以链式调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'yix'</span>)</span><br><span class="line">    .set(<span class="string">'age'</span>, <span class="number">28</span>)</span><br><span class="line">    .set(<span class="string">'job'</span>, <span class="string">'web'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123;"name" =&gt; "yix", "age" =&gt; 28, "job" =&gt; "web"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面的代码新增了三项，然后通过 <code>size</code> 属性获取了该 Map 的长度。</p>
<p>在过去，对象的键只能是字符串，很容易引发同属性名的键值覆盖的情况。但如今 Map 中可以把对象作为键值，所以，对于值相等的对象，不会导致覆盖，当然你也可以用 symbol ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">    key1 = &#123;&#125;,</span><br><span class="line">    key2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">map.set(key1, <span class="string">'a'</span>);</span><br><span class="line">map.set(key2, <span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key1)); <span class="comment">// "a"</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key2)); <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-读取项"><a href="#3-2-2-读取项" class="headerlink" title="3.2.2 读取项"></a>3.2.2 读取项</h4><p>Map 中还提供了 <code>get()</code> 方法，用于读取 Map 中包含的额项，但如果读取项的键不存在，则该方法返回 <code>undefined</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'yix'</span>)</span><br><span class="line">    .set(<span class="string">'age'</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'name'</span>)); <span class="comment">// "yix"</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'age'</span>)); <span class="comment">// 28</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'job'</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-删除项"><a href="#3-2-2-删除项" class="headerlink" title="3.2.2 删除项"></a>3.2.2 删除项</h4><p>删除项的操作和 Set 相同，该方法返回一个布尔值，若删除的项存在则返回 true，反之则返回 false：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'yix'</span>], [<span class="string">'age'</span>, <span class="number">28</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// &#123;"name" =&gt; "yix", "age" =&gt; 28&#125;</span></span><br><span class="line"></span><br><span class="line">map.delete(<span class="string">'name'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123;"age" =&gt; 28&#125;</span></span><br><span class="line"></span><br><span class="line">map.delete(<span class="string">'age'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.delete(<span class="string">'age'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>由于前面删除过 age 项，所以最后一行的删除返回 false。</p>
<h4 id="3-2-3-清空项"><a href="#3-2-3-清空项" class="headerlink" title="3.2.3 清空项"></a>3.2.3 清空项</h4><p>清空项的操作也和 Set 相同，它对于迅速清空一个包含多项的 Set 尤为方便，该方法没有返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'yix'</span>], [<span class="string">'age'</span>, <span class="number">28</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// &#123;"name" =&gt; "yix", "age" =&gt; 28&#125;</span></span><br><span class="line"></span><br><span class="line">map.clear();</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-4-判断包含"><a href="#3-2-4-判断包含" class="headerlink" title="3.2.4 判断包含"></a>3.2.4 判断包含</h4><p>判断包含项的操作和 Set 相同，如果对应的项存在，将返回 true，反之则返回 false：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'yix'</span>], [<span class="string">'age'</span>, <span class="number">28</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'name'</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.delete(<span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'name'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-Map-中的循环操作"><a href="#3-3-Map-中的循环操作" class="headerlink" title="3.3 Map 中的循环操作"></a>3.3 Map 中的循环操作</h3><p>要循环操作 Set 中的每一项，我们可以通过 <code>forEach()</code> 方法，以下代码首先读取了 Set 中的每一项，然后对每一项的值加上 ‘$$$’ 三个美元符号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'yix'</span>], [<span class="string">'age'</span>, <span class="number">28</span>]]);</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// "name" "yix"</span></span><br><span class="line"><span class="comment">// "age" 28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    map.set(key, value + <span class="string">'$$$'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123;"name" =&gt; "yix$$$", "age" =&gt; "28$$$"&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-Map-与-数组的互转"><a href="#3-4-Map-与-数组的互转" class="headerlink" title="3.4 Map 与 数组的互转"></a>3.4 Map 与 数组的互转</h3><p>为了方便数据处理，我们通常会将 Map 和 数组两者相互转化，可以通过以下方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'yix'</span>], [<span class="string">'age'</span>, <span class="number">28</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [...map1]; <span class="comment">// Map 转 数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [['name', 'yix'], ['age', 28]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'yix'</span>], [<span class="string">'web'</span>, <span class="string">'job'</span>]]); <span class="comment">// 数组 转 Map</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map2); <span class="comment">// Map &#123;"name" =&gt; "yix", "web" =&gt; "job"&#125;</span></span><br></pre></td></tr></table></figure>
<p>另外，Map 还提供了其他三个遍历方法，它们分别是：</p>
<ul>
<li>keys() : 返回键名的遍历器</li>
<li>values() : 返回键值的遍历器</li>
<li>entries() ： 返回键值对的遍历器 </li>
</ul>
<p>结合数组转换，我们可以轻松的获取到 Map 中项的键、值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'yix'</span>], [<span class="string">'age'</span>, <span class="number">28</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...map.keys()]); <span class="comment">// ["name", "age"]</span></span><br><span class="line"><span class="built_in">console</span>.log([...map.values()]); <span class="comment">// ["yix", 28]</span></span><br><span class="line"><span class="built_in">console</span>.log([...map.entries()]); <span class="comment">// [['name', 'yix'], ['age', 28]]</span></span><br></pre></td></tr></table></figure>
<h2 id="四、WeakMap"><a href="#四、WeakMap" class="headerlink" title="四、WeakMap"></a>四、WeakMap</h2><p>ES6 中引入 WeakMap 的原因和 WeakSet 相同，WeakMap 是相对 Map 来说，它的用法和 Map 类似，但 WeakMap 中的键必须是 对象，并且这种对象的引用是弱引用，它不受垃圾回收机制影响。当引用关系不存在时，则 Map 会移除对应的键值对。</p>
<p>WeakMap 有着和 Map 相同的方法，比如创建(new WeakMap)、新增项(set)、删除项(delete)、包含项判断(has)，但是没有 清空项(clear)的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> weakMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    obj = &#123;&#125;,</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">weakMap.set(obj);</span><br><span class="line">weakMap.set(arr, <span class="string">'ccc'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weakMap); <span class="comment">// WeakMap &#123;&#123;&#125; =&gt; undefined, [1, 3] =&gt; "ccc"&#125;</span></span><br><span class="line"></span><br><span class="line">weakMap.delete(obj);</span><br><span class="line"><span class="built_in">console</span>.log(weakMap); <span class="comment">// WeakMap &#123;[1, 3] =&gt; "ccc"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(weakMap.has(obj)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(weakMap.has(arr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>另外，WeakMap 还有一些其他与 Map 的不同地方：</p>
<ul>
<li>WeakMap 没有 <code>size</code> 属性，所以不能获取其中项的个数</li>
<li>WeakMap 中的项不能使用 <code>forEach()</code> 方法，所以不能读取和操作对应的项</li>
</ul>
<p>这种弱引用的关系，一般主要用于DOM事件的绑定引用。比如页面有一个按钮 btn，每点击一次，其对应的计数加 1，但当该 btn 元素被移除时，则 btn 元素对应的事件引用也被解除，这样就避免了内存泄漏。也无需手动将 btn 对应的事件设置为 null ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'.btn'</span>);</span><br><span class="line"><span class="keyword">var</span> weakMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">weakMap.set(btn, &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clickTimes = weakMap.get(btn);</span><br><span class="line">    clickTimes.count += <span class="number">1</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

  </div>

</div>

  <div class="footer">
    <a href="http://www.yi-jy.com">前端技术空间--易建勇</a> /
    <a href="http://www.beianbeian.com/search/yi-jy.com">Copyright © 2012-2018</a> /
    <a href="https://github.com/joy-yi0905/hexo-theme-record">Record</a> /
    <a href="http://yi-jy.com/atom.xml">Rss</a>
  </div>

</div>

</body>


    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7d5550c80ba3b42cfa5323fc0e92699f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


</html>