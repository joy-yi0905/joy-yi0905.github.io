<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/>

  
  <meta name="author" content="易建勇,YI_joy">
  

  
  <meta name="description" content="ES6-class | 前端技术空间">
  

  
  <meta name="keywords" content="es6 类 class">
  

  

  <title>ES6中的类 | 前端技术空间</title>

  <link rel="stylesheet" href="/css/blog.css">
</head>
<body>

<div class="blog">

<div class="navigation">
  <ul class="nav-list">
    
      <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
    
      <li class="nav-item"><a class="nav-link" href="/archives">Archives</a></li>
    
  </ul>
</div>

<div class="post">

  <h1 class="post-title">ES6中的类</h1>

  <time class="post-time">2016-07-12</time>

  <div class="post-content">
    <p>Class 在编程语言里是 类 的意思，很多面向对象语言都有这个概念和写法。其实在 ES6 之前，JavaScript 根本没有 类 的概念，更别谈 类 继承的问题了。如果你非要说有，那只不过是采用类似如下的模式来模拟的：<a id="more"></a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> Person(<span class="string">'yix'</span>);</span><br><span class="line"></span><br><span class="line">my.showName(); <span class="comment">// "yix"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(my <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>它的基本流程是这样的，首先定义一个构造函数，在函数里定义相关的属性，然后在这个构造函数的原型上添加相关方法，接着通过关键词 new 来生成一个新的实例，最后在这个实例对象上调用构造函数的相关方法。</p>
<p>在代码的最后，我们还用 <code>instanceof</code> 操作符来判断 my 是否为 Person 的实例。</p>
<p>这样，通过 Person 构造函数生成的实例，都能共享它的方法。虽然，达到了类似 类 继承 的目的，但这种做法却有些曲折，而且，在代码理解上也显得不太直白。因为直观上如果是一个类的话，属性 和 方法 应该写在一起的。</p>
<p>于是，ES6 中引入了 Class。</p>
<h2 id="一、Class-的定义"><a href="#一、Class-的定义" class="headerlink" title="一、Class 的定义"></a>一、Class 的定义</h2><p>类的定义，它是通过关键词 <code>class</code> 然后后面跟着 类名，接着是一对花括号，花括号中是这个类的 属性 和 方法。</p>
<h3 id="1-1-基本定义-声明定义"><a href="#1-1-基本定义-声明定义" class="headerlink" title="1.1 基本定义(声明定义)"></a>1.1 基本定义(声明定义)</h3><p>我们首先来看下声明定义的方式，见以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> Person(<span class="string">'yix'</span>);</span><br><span class="line"></span><br><span class="line">my.showName(); <span class="comment">// "yix"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(my <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person); <span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<p>可以看到，类 里面的代码是两个方法，它们之间没有 逗号 隔开，并且是使用 ES6 对象中方法定义的简写形式。</p>
<p>注意，倘若你使用普通语法去定义里面的方法，则代码会出现报错。另外，类 中定义属性，必须使用 <code>constructor</code> 这个函数名，否者也无法正确或者 类 的属性。</p>
<p>这段代码中 类 的定义，与上面代码 构造函数 的定义最终得结果是等价的。并且通过 <code>typeof Person</code> 我们可以知道，<code>Person</code> 类 和 上面中构造函数一样，它们本质上都是 函数。因此，ES6 中 类 的定义可以看作是一种语法糖。</p>
<p>但它们之间有几点不同：</p>
<ul>
<li>Class 内部代码的运行，默认是严格模式下，所以你无需手动设置</li>
<li>Class 中的方法都是不可枚举的</li>
<li>调用 Class 定义的类，必须使用 <code>new</code> 来创建实例，否则会报错 </li>
</ul>
<h4 id="不存在声明提升"><a href="#不存在声明提升" class="headerlink" title="不存在声明提升"></a>不存在声明提升</h4><p>在之前，函数声明可以被提升（hoisted）。即无论函数定义是在函数调用前、还是在调用后，代码都能正常运行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">5</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num1 + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 Class 并不存在这样的概念，如果不在声明 类 之前就实例化这个类，则会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> Person(<span class="string">'yix'</span>); <span class="comment">// 错误： Person is not defined</span></span><br><span class="line"></span><br><span class="line">my.showName();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-表达式定义"><a href="#1-2-表达式定义" class="headerlink" title="1.2 表达式定义"></a>1.2 表达式定义</h3><p>我们都知道，函数定义通常有这么两种方式：函数声明、函数表达式。前面说过，类 在本质上也是函数，因此它和函数一样，也有这么两种形式。</p>
<p>通过 表达式 的形式来定义类，只需要将 类名 前置到 class 前面，像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> Person(<span class="string">'yix'</span>);</span><br><span class="line"></span><br><span class="line">my.showName(); <span class="comment">// "yix"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(my <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person); <span class="comment">// "function"</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.name); <span class="comment">// "Person"</span></span><br></pre></td></tr></table></figure>
<p>此时，我们看到 类名 为 Person 。</p>
<p>当然，如果你想省略将实例化对象赋值给变量这一步的话，你可以通过这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">'yix'</span>);</span><br><span class="line"></span><br><span class="line">my.showName(); <span class="comment">// "yix"</span></span><br></pre></td></tr></table></figure>
<h4 id="命名的表达式定义"><a href="#命名的表达式定义" class="headerlink" title="命名的表达式定义"></a>命名的表达式定义</h4><p>上面的例子相当于创建了一个匿名的 类，为了方便起见，你也可以像命名函数那样，给 表达式 进行命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonInner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showClassName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> Person(<span class="string">'yix'</span>);</span><br><span class="line"></span><br><span class="line">my.showName(); <span class="comment">// "yix"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(my <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonInner); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.name); <span class="comment">// PersonInner</span></span><br></pre></td></tr></table></figure>
<p>看到，代码依旧正常、等价的运行。只是不同的是，在 class 外部，PersonInner 的数据类型是 undefined 。</p>
<p>或许你会觉得，在 class 后面跟着一个 标识符 有什么用呢？因为它的值是 undefined，在 class 外部，它根本不具备标识类的功能啊。</p>
<p>的确如此，PersonInner 可以用在内部，表示当前类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonInner</span> </span>&#123;</span><br><span class="line">    showClassName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(PersonInner.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">my.showClassName(); <span class="comment">// "PersonInner"</span></span><br></pre></td></tr></table></figure>
<p>它只能在类的方法定义中，如果用在 constructor 里，则会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonInner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(PersonInner.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> Person(<span class="string">'yix'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.name); <span class="comment">// "PersonInner"</span></span><br></pre></td></tr></table></figure>
<h2 id="二、Class-的继承"><a href="#二、Class-的继承" class="headerlink" title="二、Class 的继承"></a>二、Class 的继承</h2><p>在 ES6 中，我们可以通过 <code>extends</code> 关键字来轻松的实现继承，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码表示，类 B 继承了 A 的所有属性和方法。</p>
<p>但是，因为子类自身没有 this 对象。它必须通过在子类的 <code>constructor</code> 函数中使用 <code>super</code> 关键字，调用 <code>super()</code> 方法。这样才能获取到对应的 this，以下是最简单的 <code>super</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// console.log(this); // 错误：this is not defined</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// B &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
<p>由上面的代码，我们可以知道，在 <code>super()</code> 调用之后， 返回了 子类 的实例，才能使用 this 对象。否者，会抛出错误。</p>
<p>这里演示了 B类 继承了 A类 的 showName 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="string">'bbb'</span>);</span><br><span class="line"></span><br><span class="line">b.showName(); <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure>
<p><code>super</code> 一般有两种用途，即 函数调用 和 对象访问。</p>
<h4 id="super-的函数调用"><a href="#super-的函数调用" class="headerlink" title="super 的函数调用"></a>super 的函数调用</h4><p>函数调用 是最常用的方法，它主要用于 子类 继承 父类 时，在 <code>constructor</code> 函数中作为 父类 构造函数的引用，返回 子类 的实例，这样，我们就能在 子类 中使用 this 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> A(); <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B(); <span class="comment">// B</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>new.target</code> 表示当前执行的函数。这里的 <code>new A()</code> 和 <code>new B()</code> 返回的结果都是自身的 类 的构造函数。</p>
<h4 id="super-的对象访问"><a href="#super-的对象访问" class="headerlink" title="super 的对象访问"></a>super 的对象访问</h4><p>而对于 对象访问，则表示在 子类 中，<code>super</code> 这个对象是父类的 原型对象。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  showNumber() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.showNumber()); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
<p>上面代码中，类A 的原型上定义了一个方法 <code>showNumber</code>，所以在 类B 中 <code>super.showNumber</code> 就表示访问 类A 原型对象上的 <code>showNumber</code> 方法，因此返回 1 。</p>
<h2 id="三、Class-构造函数中-new-target"><a href="#三、Class-构造函数中-new-target" class="headerlink" title="三、Class 构造函数中     new.target"></a>三、Class 构造函数中     new.target</h2><p>还记得吗？在描述 Class 的继承 这一小节中，我们提到了 <code>new.target</code> 属性，它的值取决于是在哪个 Class 下的函数里被使用。这样的话，我们可以通过它，来确定哪个类被调用了。</p>
<p>来个最简单的验证：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但对于有继承关系的实例化对象，则 <code>new.target</code> 将返回的是 子类 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === A);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure>
<p>不过要注意的是，<code>new.target</code> 属性只能使用在 <code>constructor</code> 函数内部，否者会报错。</p>
<h2 id="四、Class-的静态方法"><a href="#四、Class-的静态方法" class="headerlink" title="四、Class 的静态方法"></a>四、Class 的静态方法</h2><p>什么是静态方法？我们知道，Class 中定义的方法，都会被其创建的实例所继承。但如果你不希望实例继承 类 的方法，你可以在定义方法时，在前面加上关键词 <code>static</code>，而这种通过前置 <code>static</code> 关键词所定义的方法，就是 静态方法。</p>
<p>静态方法，只能通过 Class 自身进行调用。来看下相关演示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'yix'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> showJob() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'web'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">A.showJob(); <span class="comment">// "web"</span></span><br><span class="line"></span><br><span class="line">a.showName(); <span class="comment">// "yix"</span></span><br><span class="line">a.showJob(); <span class="comment">// 错误：a.showJob is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面的代码分别在 A类 上定义了一个 普通（动态或实例）的方法 <code>showName</code> 和 静态方法 <code>showJob</code>。可以看到，静态方法只能在 A类（类本身）上进行调用，而在实例上则直接跑错。</p>
<h2 id="五、Class-的成员名称"><a href="#五、Class-的成员名称" class="headerlink" title="五、Class 的成员名称"></a>五、Class 的成员名称</h2><p>像以字面量的形式定义对象一样，Class 中的 方法 名不一定非要使用 标识符，你同样也可以使用计算名，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcName = <span class="string">'showName'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [funcName]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// "yix"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A(<span class="string">'yix'</span>);</span><br><span class="line"></span><br><span class="line">a.showName();</span><br></pre></td></tr></table></figure>
<h2 id="六、Class-的Generator方法"><a href="#六、Class-的Generator方法" class="headerlink" title="六、Class 的Generator方法"></a>六、Class 的Generator方法</h2><p>类似的，也可以在 Class 中添加 Generator函数 ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(arr) &#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *showNumber() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> <span class="keyword">this</span>.arr) &#123;</span><br><span class="line">            <span class="keyword">yield</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A([<span class="string">'aa'</span>, <span class="string">'bb'</span>, <span class="string">'cc'</span>]),</span><br><span class="line">    g = a.showNumber();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(g.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(g.next().value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// "aa"</span></span><br><span class="line"><span class="comment">// "bb"</span></span><br><span class="line"><span class="comment">// "cc"</span></span><br></pre></td></tr></table></figure>
<h2 id="七、Class-的-get-和-set"><a href="#七、Class-的-get-和-set" class="headerlink" title="七、Class 的 get 和 set"></a>七、Class 的 get 和 set</h2><p>在 ES5 中，我们可以通过关键词 <code>get</code> 和 <code>set</code> 来实现 getter 和 setter，从而读取和设置对象的属性。</p>
<p>而在 ES6 的 Class 中，虽然有关属性的操作都是在构造函数 constructor 中，但通过上面的描述，我们知道 对象 与 Class 有很多相似之处，当然，我们也可以通过 <code>get</code> 和 <code>set</code> 来进行属性的操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(arr) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get prop() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'aa'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set prop(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'新值: '</span>+ value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.prop); <span class="comment">// "aa"</span></span><br><span class="line"></span><br><span class="line">a.prop = <span class="string">'bb'</span>; <span class="comment">// 新值: "bb"</span></span><br></pre></td></tr></table></figure>
<p>由上面的代码，我们可以知道，当 Class 属性被设置新值时，无需读取，对应的属性值就立马呈现出来。很多前端 MVVM 库中的单向数据绑定，都是基于此原理来实现的。</p>

  </div>

</div>

  <div class="footer">
    <a href="http://www.yi-jy.com">前端技术空间--易建勇</a> /
    <a href="http://www.beianbeian.com/search/yi-jy.com">Copyright © 2012-2018</a> /
    <a href="https://github.com/joy-yi0905/hexo-theme-record">Record</a> /
    <a href="http://yi-jy.com/atom.xml">Rss</a>
  </div>

</div>

</body>


    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7d5550c80ba3b42cfa5323fc0e92699f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


</html>