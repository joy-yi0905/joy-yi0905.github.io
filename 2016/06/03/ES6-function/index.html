<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/>

  
  <meta name="author" content="易建勇,YI_joy">
  

  
  <meta name="description" content="ES6-function | 前端技术空间">
  

  
  <meta name="keywords" content="es6 函数">
  

  

  <title>ES6中的函数 | 前端技术空间</title>

  <link rel="stylesheet" href="/css/blog.css">
</head>
<body>

<div class="blog">

<div class="navigation">
  <ul class="nav-list">
    
      <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
    
      <li class="nav-item"><a class="nav-link" href="/archives">Archives</a></li>
    
  </ul>
</div>

<div class="post">

  <h1 class="post-title">ES6中的函数</h1>

  <time class="post-time">2016-06-03</time>

  <div class="post-content">
    <p>函数对于任何编程语言都是不可或缺的，在 ES6 出现之前，函数存在诸多问题，最典型的要数 this的指向问题，不同的调用方式、不同的写法，函数内部的 this 也会相应不同。用代码来说明下：<a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newSum = <span class="keyword">new</span> Sum();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">    sum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    timer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum()); <span class="comment">// window</span></span><br><span class="line"><span class="built_in">console</span>.log(newSum); <span class="comment">// sum</span></span><br><span class="line"><span class="built_in">console</span>.log(counter.sum()); <span class="comment">// counter</span></span><br><span class="line"><span class="built_in">console</span>.log(counter.timer()); <span class="comment">// counter window</span></span><br></pre></td></tr></table></figure>
<p>通过上面的代码，你会发现全局函数直接调用 this 会返回 window对象，而全局函数的构造函数则返回它的 实例对象，另外如果你使用对象属性的方式来定义函数，并在这个对象上调用时，则 this 又变成对象本身。但是如果遇到 <code>setInterval</code> 或者 <code>setTimeout</code> 这样的内置函数，其内部的 this 又变成了 window对象。是不是很乱？更不要说还可以使用 apply、call改变this了。</p>
<p>再者，我们在写插件时，为了防止用户不设置相关属性值，通常都会给一些参数设置默认值，但是需要使用 <code>||</code> 或符号，有点麻烦：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    num1 = num1 || <span class="number">1</span>;</span><br><span class="line">    num2 = num2 || <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum()); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>倘若函数有多个参数，那就需要把所有的参数以及默认值都写一遍，那岂不是更麻烦？如果能够直接把参数默认值塞到函数名后面的括号里，是不是会更好一些？</p>
<p>接下来，看看 ES6 对函数部分作了哪些调整和改进。</p>
<h2 id="一、默认参数"><a href="#一、默认参数" class="headerlink" title="一、默认参数"></a>一、默认参数</h2><p>针对前面提到的参数问题，ES6 新增了 默认参数 的概念，旨在更高效的设置参数默认值，只需要给对应参数赋值即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 = <span class="number">1</span>, num2 = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum()); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>如上面代码，<code>sum()</code> 没有传递一个参数，使用两个参数的默认值，而 <code>sum(5)</code> 则只使用了 num2 的默认值，但 <code>sum(5, 5)</code> 则是不用任何一个参数默认值，全部重新定义。</p>
<p>通过设置参数默认值，这也就表明，<code>sum</code> 函数中的两个参数都是可选的。 </p>
<p>值得一提的是，如果传入的参数为 <code>null</code> 或者 <code>undefined</code>，则情况会有些不同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 = <span class="number">1</span>, num2 = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="literal">null</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="literal">undefined</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="string">''</span>)); <span class="comment">// "2"</span></span><br></pre></td></tr></table></figure>
<p><code>null</code> 会替换掉默认值，它自身被隐式转化为 0，所以结果为 2。</p>
<p>而 <code>undefined</code> 则直接使用默认值，因此，结果为 3。</p>
<p>另外，空字符串可能会出乎你的所料（你一定觉得它会使用默认值），但实际上，它却替换默认值，所以，结果为 <code>&#39;&#39; + 2</code>，即字符串 <code>&quot;2&quot;</code>。</p>
<h3 id="1-1-参数表达式"><a href="#1-1-参数表达式" class="headerlink" title="1.1 参数表达式"></a>1.1 参数表达式</h3><p>参数的默认值不仅仅只能用一个静态值来表示，它也可以是一个变量，一个表达式。你只需要把变量或表达式赋值给参数，作为参数的默认值即可。比如，后面的参数默认值可以是前面参数的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 = <span class="number">1</span>, num2 = num1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>当然，这个参数表达式也可以是一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">para</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 = <span class="number">1</span>, num2 = para(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>或许你会好奇，为什么同样都是打印出 <code>sum(2)</code>，但每次结果都是不一样呢？</p>
<p>这里就需要注意，<code>para()</code> 这个表达式(函数)只会在 <code>sum(2)</code> 调用时才会执行。因为 a 是全局变量，<code>para()</code> 内部又每次对 a 进行加 1，从而导致参数 num2 的默认值不同，最终打印出的结果也不同。</p>
<h3 id="1-2-作用域"><a href="#1-2-作用域" class="headerlink" title="1.2 作用域"></a>1.2 作用域</h3><p>如果参数是一个变量，那它最终返回的值会受函数的作用域影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2 = num1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>函数中参数 num1 的值是来自函数内部，而非全局变量。</p>
<p>如果参数是一个函数，则直接读取全局的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num2 = function(</span>) </span>&#123; <span class="keyword">return</span> num1; &#125;) &#123;</span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> num2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-函数的length"><a href="#1-3-函数的length" class="headerlink" title="1.3 函数的length"></a>1.3 函数的length</h3><p>我们都知道，函数有一个length属性，它的值是函数形参的个数，即：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">num1, num2</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.length); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>但 ES6 对这个属性有所调整，它的值变成了没有指定参数默认值的形参个数。换句话说就是，如果某个参数已经指定了默认值，那么它就不能被包含在 length 属性中。还是用代码来说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">num1 = <span class="number">1</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum3</span>(<span class="params">num1, num2, num3 = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum4</span>(<span class="params">num1 = <span class="number">1</span>, num2, num3</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum5</span>(<span class="params">num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2.length); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(sum3.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(sum4.length); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(sum5.length); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><code>sum4</code> 和 <code>sum5</code> 的结果可能让你有点意外。它反映了一个特殊情况，即：如果有默认值的参数不在参数列表的最后一位，则函数 length 的值都为 0 。</p>
<h2 id="二、rest参数"><a href="#二、rest参数" class="headerlink" title="二、rest参数"></a>二、rest参数</h2><p>之前，我们在处理多位参数时，都是基于 arguments 对象进行操作。但为了更方便的处理不确定的多位参数，ES6 引入了 rest参数 ，它是由三个点加变量名组成，即 <code>...变量名</code>，表示剩余参数。先来看下它的用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...Args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Args.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(); <span class="comment">// 0</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>或许你会觉得，用 <code>arguments.length</code> 也能正常获取形参长度。的确如此，但是 arguments 只是一个类似数组的对象，而 rest参数 却是一个数组。它可以使用数组的各种方法和属性，这样在函数内部操作时更方便，就拿参数拼接来说吧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">...Args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Args.join(<span class="string">'-'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 1-2-3-4-5</span></span><br></pre></td></tr></table></figure>
<p>使用 rest参数 来操作，秒秒钟就能输出结果。但是，使用 arguments ，势必需要逐个循环，然后再进行字符串拼接。</p>
<p>你也可以用它排序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ascendSort</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">descendSrot</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num2 - num1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">sort, ...Args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Args.sort(sort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(join(ascendSort, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">-3</span>)); <span class="comment">// [-3, 2, 3, 6, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(join(descendSrot, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">-3</span>)); <span class="comment">// [9, 6, 3, 2, -3]</span></span><br></pre></td></tr></table></figure>
<p><code>join</code> 函数的第一个参数是 <code>sort</code>，而其他参数就是 <code>...Args</code> 。</p>
<p>不过，在使用 rest参数 时，也有一些需要注意的地方。</p>
<ul>
<li>rest参数 必须是参数列表的最后一个</li>
<li>rest参数 不包含在函数的length</li>
</ul>
<p>用代码来说明下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...Args, last</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Args.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 报错：Uncaught SyntaxError: Rest parameter must be last formal parameter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum1</span>(<span class="params">num1, num2, ...Args</span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum1.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="三、扩展运算符"><a href="#三、扩展运算符" class="headerlink" title="三、扩展运算符"></a>三、扩展运算符</h2><p>与 rest参数 相反的一个概念，是 扩展运算符。扩展运算符 指定一个数组并把这个数组拆分开来逐个作为参数传递给函数。</p>
<p>它也是用三个点加变量名组成，即 <code>...变量名</code>。</p>
<p>先来看下它的一些简单应用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">-3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr)); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr, <span class="number">10</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">20</span>, ...[<span class="number">3</span>, <span class="number">50</span>], <span class="number">10</span>)); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>以上代码是求所有数的最大值。无论是只传入 扩展运算符，还是传入 扩展运算符 和其他参数。它都是将所有的数字拆分后，然后进行比较，最后返回最大值的。</p>
<p>用于函数调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2, num3</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2 + num3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(...[<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>])); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>用于数组与单项、以及多个数组之间的合并：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, ...[<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="literal">null</span>, <span class="number">5</span>]); <span class="comment">// [1, 2, "a", "b", null, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], ...[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], ...[<span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">undefined</span>]]);</span><br><span class="line"><span class="comment">// [1, 2, 3, "a", "b", "c", null, false, undefined]</span></span><br></pre></td></tr></table></figure>
<h2 id="四、name属性"><a href="#四、name属性" class="headerlink" title="四、name属性"></a>四、name属性</h2><p>对于函数而言，除了之前提到的 length属性 外，它还有 name属性。表示当前函数的名称，这个属性或许对于代码的调试有一定的帮助。</p>
<p>无论你使用哪种方式去定义一个函数，它都会有 name属性，就像下面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum1.name); <span class="comment">// sum1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2.name); <span class="comment">// ''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 </span></span><br><span class="line"><span class="built_in">console</span>.log(sum2.name); <span class="comment">// sum2</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果是用变量声明的匿名函数，那么它返回的函数名会有所不同。在支持ES6的浏览器(chrome54 测)返回的是 变量名，而ES5浏览器(firefox49 测)则返回 空字符串 。</p>
<p>倘若你用变量声明的是一个具名函数，那么无论是否支持ES6，都会返回具名函数的名称。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> <span class="title">spe</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.name); <span class="comment">// spe</span></span><br></pre></td></tr></table></figure>
<p>由于函数的变种(写法)很多，所以可能会出现一些特殊的name属性，比如，对象上定义的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">console</span>.log(number.add.name); <span class="comment">// ''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="built_in">console</span>.log(number.add.name); <span class="comment">// add</span></span><br></pre></td></tr></table></figure>
<p>比如，函数上调用 <code>bind()</code> 方法后，返回的name值是带 <code>bound</code> 前缀的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.bind().name); <span class="comment">// bound sum</span></span><br></pre></td></tr></table></figure>
<p>再比如，构造函数实例的name值是 <code>anonymous</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name); <span class="comment">// anonymous</span></span><br></pre></td></tr></table></figure>
<h2 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h2><p>ES6 中新增了一种函数的写法，即 箭头函数。箭头函数就是个简写形式的函数表达式，如它的名称所描述的，它用一个 <code>=&gt;</code> 符号来定义一个函数。</p>
<p>先来看下它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个参数</span></span><br><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数时，圆括号是可选的</span></span><br><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数时，左边需要空的圆括号:</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
<p>由这几段语法可以知道，箭头函数式主要由三部分组成。首先是 函数的参数、后面跟着 <code>=&gt;</code> 符号，最后是 函数体。</p>
<p>从上面的代码也可以看出，箭头函数的不同写法，关键在于参数的个数。</p>
<p>当函数有参数多个时，左边必须是多个参数包含在一个圆括号中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当函数只有一个参数时，左边的圆括号可以省略（也可以加上）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> increase = <span class="function"><span class="params">num</span> =&gt;</span> num + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> increase = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当函数没有一个参数时，则左边必须使用空的圆括号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getThis = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> getThis = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了参数以外，右边的函数体写法也有可能不同。如果你的函数体内有零个或多个表达式，你必须使用花括号把它们包含起来。</p>
<p>像定义一个空函数，你可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> noop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>又比如，函数体内多个表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sqrtRoot = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = num1*num1 + num2*num2;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(temp);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sqrtRoot(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>如果你函数返回的是一个对象，你不能把对象直接写在 <code>=&gt;</code> 符号后面，这样会导致报错。你<strong>要么</strong>使用 一对圆括号 把返回的对象包含起来，<strong>要么</strong>使用 花括号 再包一层：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getObj1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="attr">name</span>: <span class="string">'yix'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getObj2 = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;<span class="attr">name</span>: <span class="string">'yix'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getObj3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'yix'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getObj1()); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(getObj2()); <span class="comment">// &#123;name: "yix"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(getObj3()); <span class="comment">// &#123;name: "yix"&#125;</span></span><br></pre></td></tr></table></figure>
<p>即： 如果 <code>=&gt;</code> 符号后面是 <code>()</code> 圆括号，则表示函数执行后返回圆括号的内容。 如果 <code>=&gt;</code> 符号后面是 <code>{}</code> 花括号，则表示函数执行后会运行花括号里的内容。</p>
<p>值得注意的是，虽然箭头函数很好用，但是它和传统的函数还是有很多的区别。</p>
<h3 id="5-1-不绑定-this"><a href="#5-1-不绑定-this" class="headerlink" title="5.1 不绑定 this"></a>5.1 不绑定 this</h3><p>由文章开头我们知道，this 在函数调用中可以说是千变万化，它返回的值取决它的执行环境(context)。但是在箭头函数却不会有这样的问题，它返回的就是定义时所在的对象。</p>
<p>不使用箭头函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num); <span class="comment">// NaN</span></span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Increase();</span><br></pre></td></tr></table></figure>
<p>使用箭头函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.num++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// increase</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num); <span class="comment">// 2</span></span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Increase();</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，不使用箭头函数，setTimeout 函数内部的this默认是 window，但全局中根本没有 num 这个变量，于是就变成了 window.num + 1 ，最后得到的结果是 NaN。</p>
<p>但在使用了箭头函数后，它可以让 this 不绑定运行的环境，而是把 this 指向了定义所在的环境。因此可以找到 num 的值为 1，递增后的结果为 2 。</p>
<h3 id="5-2-不绑定-arguments"><a href="#5-2-不绑定-arguments" class="headerlink" title="5.2 不绑定 arguments"></a>5.2 不绑定 arguments</h3><p>在普通函数中，我们可以轻松的访问到 参数对象-arguments，但是你却不能在箭头函数里访问它，因为箭头函数没有 arguments对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum1 = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum2 = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum1(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// arguments is not defined</span></span><br></pre></td></tr></table></figure>
<p>但如果箭头函数是在普通函数里访问 arguments对象，则又能正常访问，因为此时访问到的 arguments对象 是普通函数的，而非箭头函数的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum3 = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum3(<span class="number">1</span>, <span class="number">2</span>)()); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-new-操作符"><a href="#5-3-new-操作符" class="headerlink" title="5.3 new 操作符"></a>5.3 new 操作符</h3><p>箭头函数不能用作构造器，若尝试用 new 来构造一个函数，则会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total = <span class="keyword">new</span> Sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// sum is not a constructor</span></span><br></pre></td></tr></table></figure>
<p>总结起来，箭头函数有这么几个特点：</p>
<ul>
<li>没有 <code>this</code>、<code>arguments</code> 、<code>new.target</code> 的绑定</li>
<li>不能用 <code>new</code> 来构造函数。若强行使用，则会抛出一个错误</li>
<li>没有 <code>prototype</code>。构造函数都没有了，要 <code>prototype</code> 干嘛</li>
<li>函数内部没有 <code>arguments</code> 对象。你可以用 Rest参数 代替它</li>
<li>不能有同名的参数</li>
</ul>
<h2 id="六、尾调用优化"><a href="#六、尾调用优化" class="headerlink" title="六、尾调用优化"></a>六、尾调用优化</h2><p>首先，必须说明的是，尾调用优化 是 ES6 针对一些性能消耗比较高的代码（比如递归函数）而引入的js引擎优化，它只是一种概念，一个优化手段，而并非是代码或者语法的某种特殊写法。</p>
<p>其他语言早就已经有 尾调用优化 的概念和应用了，我相信，ES6 肯定是借鉴它们的。</p>
<p>要明白什么是尾调用优化，你当然首先需要知道 尾调用。</p>
<p>所谓的 尾调用，就是一个函数在另外一个函数内部的最后一行进行调用。换言之，尾调用是发生在当一个函数尾部返回另一个函数调用时。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果最后返回的调用函数是本身，则这种调用，简称 尾递归。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，以下的情况并不是尾调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> total = num * factorial(num - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sum</code> 函数里最后一行虽然返回了一个函数调用，但是它是先做了加性操作符运算，然后再返回的，所以它不算。而 <code>factorial</code> 函数最后一行返回的根本不是直接调用的函数，只是达到同等的效果而已，因此它也不能算尾调用。</p>
<p>虽然普通函数也能用到尾调用优化，但为了更深入的阐述尾调用优化的作用，我们就来说说最具有代表性的尾递归，阶层求值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * f(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们运行 <code>f(5)</code> 时，会执行下列过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f(<span class="number">5</span>)</span><br><span class="line">↓</span><br><span class="line"><span class="number">5</span> * f(<span class="number">4</span>)</span><br><span class="line">↓</span><br><span class="line"><span class="number">5</span> * <span class="number">4</span> * f(<span class="number">3</span>)</span><br><span class="line">↓</span><br><span class="line"><span class="number">5</span> * <span class="number">4</span> * <span class="number">3</span> * f(<span class="number">2</span>)</span><br><span class="line">↓</span><br><span class="line"><span class="number">5</span> * <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span> * f(<span class="number">1</span>)</span><br><span class="line">↓</span><br><span class="line"><span class="number">5</span> * <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这种递归的写法并不能使用尾调用优化，因为 <code>f</code> 函数的最后行为不是返回单纯的函数调用。而且因为需要引用前面的关系，就会加入一层一层的堆栈帧，当 <code>n</code> 很大时，很有可能导致堆栈溢出。</p>
<p>我们把上面的函数改动一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = m || <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2(n - <span class="number">1</span>, m * n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，<code>f2</code> 最后返回了一个函数调用，并且使用参数 <code>m</code> 保存了每次计算后的值。运行 <code>f2(5)</code> 它就转化为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f2(<span class="number">5</span>)</span><br><span class="line">↓</span><br><span class="line">f2(<span class="number">4</span>, <span class="number">1</span> * <span class="number">5</span>)</span><br><span class="line">↓</span><br><span class="line">f2(<span class="number">3</span>, <span class="number">1</span> * <span class="number">5</span> * <span class="number">4</span>)</span><br><span class="line">↓</span><br><span class="line">f2(<span class="number">2</span>, <span class="number">1</span> * <span class="number">5</span> * <span class="number">4</span> * <span class="number">3</span>)</span><br><span class="line">↓</span><br><span class="line">f2(<span class="number">1</span>, <span class="number">1</span> * <span class="number">5</span> * <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span>)</span><br><span class="line">↓</span><br><span class="line"><span class="number">1</span> * <span class="number">5</span> * <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这样，就变成了一个接一个、无需引用前面的堆栈帧，并且是相互独立的函数调用了。</p>
<p>最后，值得注意的是，你必须在严格模式下，尾调用优化才能生效！</p>

  </div>

</div>

  <div class="footer">
    <a href="http://www.yi-jy.com">前端技术空间--易建勇</a> /
    <a href="http://www.beianbeian.com/search/yi-jy.com">Copyright © 2012-2018</a> /
    <a href="https://github.com/joy-yi0905/hexo-theme-record">Record</a> /
    <a href="http://yi-jy.com/atom.xml">Rss</a>
  </div>

</div>

</body>


    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7d5550c80ba3b42cfa5323fc0e92699f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


</html>