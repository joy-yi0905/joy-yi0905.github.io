<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/>

  
  <meta name="author" content="易建勇,YI_joy">
  

  
  <meta name="description" content="ES6-object | 前端技术空间">
  

  
  <meta name="keywords" content="es6 对象">
  

  

  <title>ES6中的对象 | 前端技术空间</title>

  <link rel="stylesheet" href="/css/blog.css">
</head>
<body>

<div class="blog">

<div class="navigation">
  <ul class="nav-list">
    
      <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
    
      <li class="nav-item"><a class="nav-link" href="/archives">Archives</a></li>
    
  </ul>
</div>

<div class="post">

  <h1 class="post-title">ES6中的对象</h1>

  <time class="post-time">2016-06-10</time>

  <div class="post-content">
    <p>对象是一组数据和功能的集合，在我们日常编程中必不可缺，ES6 在对象方面做了很多改进，一起来看下。<a id="more"></a></p>
<h2 id="一、对象字面量扩展"><a href="#一、对象字面量扩展" class="headerlink" title="一、对象字面量扩展"></a>一、对象字面量扩展</h2><h3 id="1-1、对象属性简写"><a href="#1-1、对象属性简写" class="headerlink" title="1.1、对象属性简写"></a>1.1、对象属性简写</h3><p>要定义一个对象，为了简单方便起见，通常会使用对象字面量的形式，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'yix'</span>,</span><br><span class="line">    age = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "yix", age: 28&#125;</span></span><br></pre></td></tr></table></figure>
<p>都是相同名称，或许，你会觉得在 <code>person</code> 对象里要写两遍 <code>name</code> 和 <code>age</code> 显得比较繁琐。针对这个问题，ES6提供了一个简写方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'yix'</span>,</span><br><span class="line">    age = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "yix", age: 28&#125;</span></span><br></pre></td></tr></table></figure>
<p>如上面代码所看到的，所谓的简写方式主要是通过去除对象属性后面的 冒号，以及相同名称的属性值。</p>
<p>所以，在 ES6 中，以下两种写法也是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;name, age&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前后写法等价</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">name</span>: name, <span class="attr">age</span>: age&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person(<span class="string">'yix'</span>, <span class="number">28</span>)); <span class="comment">// &#123;name: "yix", age: 28&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-函数简写定义"><a href="#1-2-函数简写定义" class="headerlink" title="1.2 函数简写定义"></a>1.2 函数简写定义</h3><p>类似地，除了对象属性简写外，ES6 还引入了函数定义的简写。如，下面两种写法是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前后写法等价</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span>,</span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.showName(); <span class="comment">// 'yix'</span></span><br></pre></td></tr></table></figure>
<p>通过对比，我们可以发现，在对象中函数简写定义就是去除 冒号，以及关键词 <code>function</code> 。这样一来，整体代码变小，也提高了编码效率。</p>
<h3 id="1-3-获取属性名"><a href="#1-3-获取属性名" class="headerlink" title="1.3 获取属性名"></a>1.3 获取属性名</h3><p>对象字面量是一组键值对的组合。一般来说，要设置或获取对象中的属性值，主要有两种方式，通过 方括号 <code>[]</code> 或者使用 点号 <code>.</code>。如下面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'yix'</span>;</span><br><span class="line">person[<span class="string">'age'</span>] = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'name'</span>], person[<span class="string">'age'</span>]); <span class="comment">// 'yix' 28</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name, person.age); <span class="comment">// 'yix' 28</span></span><br></pre></td></tr></table></figure>
<p>这两种获取属性值的方式各有优缺点，点号 <code>.</code> 方式书写更简洁，但对于一些特殊的属性名，比如，当属性名中包含空格时，它无法正常获取属性值，甚至会抛出一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">'my name'</span>: <span class="string">'yix'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'my name'</span>]); <span class="comment">// 'yix'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.my name); <span class="comment">// 报错 missing ) after argument list</span></span><br></pre></td></tr></table></figure>
<p>由上面代码，方括号 <code>[]</code> 这种形式则不会受含有空格属性名的限制，但它的写法相对于 点号 <code>.</code> 来说又繁琐了些。</p>
<p>在 ES6 中，我们可以使用变量来定义对象中的属性，同时，也可以使用该变量（或等价的值）来获取对象下对应的属性值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="string">'my name'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    [myName]: <span class="string">'yix'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[myName], person[<span class="string">'my name'</span>]); <span class="comment">// 'yix' 'yix'</span></span><br></pre></td></tr></table></figure>
<p>这样的好处是，我们可以同时在对象内部或外部（其他函数或对象）使用这个变量。</p>
<p>其实，不仅仅如此。ES6 还允许我们通过 表达式 的方式来定义属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">' name'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    [<span class="string">'my'</span> + name]: <span class="string">'yix'</span>,</span><br><span class="line">    [<span class="string">'you'</span> + name]: <span class="string">'guest'</span>,</span><br><span class="line">    [<span class="string">'show'</span> + name]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>[<span class="string">'my name'</span>], <span class="keyword">this</span>[<span class="string">'you name'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person[<span class="string">'show name'</span>](); <span class="comment">// 'yix' 'guest'</span></span><br></pre></td></tr></table></figure>
<h2 id="二、对象方法扩展"><a href="#二、对象方法扩展" class="headerlink" title="二、对象方法扩展"></a>二、对象方法扩展</h2><h3 id="2-1-Object-is"><a href="#2-1-Object-is" class="headerlink" title="2.1 Object.is()"></a>2.1 Object.is()</h3><p>要比较两个数据是否相等，我们通常会使用 <code>==</code> 和 <code>===</code>。因为使用 <code>==</code> 作比较时，右边的数据会先作类型转换再进行比较，这样就会经常出现一些不同类型的数据却相等的情况。所以，在平常的开发中，我们更倾向于使用 <code>===</code>，因为它是直接比较，只有完全相等的两个数据才会返回 <code>true</code>。</p>
<p>ES6 中在对象上新增了 <code>Object.is()</code> 方法，我们用它来判断两个数据是否完全相等，它的作用和 <code>===</code> 基本相同，但也有略微差异：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span> === <span class="string">'10'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">10</span>, <span class="string">'10'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>其实，在我们看来，+0 和 0 的确是不等，但 <code>===</code> 却返回了 <code>true</code>，而 <code>Object.is(+0, -0)</code> 则是返回 <code>false</code>。</p>
<p>ES5中规定，<code>NaN</code> 与任何值（甚至自身）都不相等，所以 <code>===</code> 返回了 <code>false</code> 。但实际上，我们会觉得这种设计是存在缺陷的，为什么 <code>NaN</code> 不等于 <code>NaN</code> ？所以， <code>Object.is(NaN, NaN)</code> 返回的结果是 <code>true</code>。</p>
<p>而对于一些正常数据的比较，基本和 <code>===</code> 返回的值是相同的。</p>
<h3 id="2-2-Object-assign"><a href="#2-2-Object-assign" class="headerlink" title="2.2 Object.assign()"></a>2.2 Object.assign()</h3><p>在我们平时编码中，会经常执行合并对象的操作。如果你是用 jquery库，你可以使用它现成的 API，即 <code>$.extend(target, sources1, sources2)</code>。但如果你是用原生js，那你只能先循环读取一个或多个源对象，再循环读取每个源对象下的属性，并把这些属性赋值到目标对象上，以下是简单实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.assign != <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line"><span class="meta">        'use strict'</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot convert undefined or null to object'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        target = <span class="built_in">Object</span>(target);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">1</span>; index &lt; <span class="built_in">arguments</span>.length; index++) &#123;</span><br><span class="line">            <span class="keyword">var</span> source = <span class="built_in">arguments</span>[index];</span><br><span class="line">            <span class="keyword">if</span> (source != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">                        target[key] = source[key];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ES6 中，<code>Object.assign()</code> 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 它的语法如下，其中 target 为目标对象，而 sources 为任意多个源对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br></pre></td></tr></table></figure>
<p>来看它的一些实际例子，首先是合并多个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    sources1 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    sources2 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(target, sources1, sources2)); <span class="comment">// &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>当源对象中和目标对象之间、或者源对象和源对象之间，有属性名是相同的，则后面对象的属性值会覆盖前面的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    sources1 = &#123;<span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    sources2 = &#123;<span class="attr">b</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(target, sources1, sources2)); <span class="comment">// &#123;a: 2, b: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>属性值是基本类型还好，但倘若属性值为复杂类型，则通常会出现一些值得丢失，因为会被覆盖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">people</span>: &#123;<span class="attr">name</span>: <span class="string">'yix'</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;&#125;,</span><br><span class="line">    obj2 = &#123;<span class="attr">people</span>: &#123;<span class="attr">job</span>: <span class="string">'web'</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(obj1, obj2)); <span class="comment">// &#123;people: &#123;job: 'web'&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果该方法的参数是原始类型，则它会把该参数转换为对象，并且需要注意的是，只有字符串类型才能被枚举出来，而数字类型、布尔类型只会转换为对应的包装对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> v4 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.assign(v1);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(v2);</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>.assign(v3); </span><br><span class="line"><span class="keyword">var</span> obj4 = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, <span class="literal">null</span>, v2, <span class="literal">undefined</span>, v3, v4); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;0: 'a', 1: 'b', 2: 'c', length: 3, [[PrimitiveValue]]: 'abc'&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">// &#123;[[PrimitiveValue]]: 10&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// &#123; '0': 'a', '1': 'b', '2': 'c' &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果该方法的参数是数组，它同样会把数组当成对象来处理。比如 [‘a’, ‘b’] 会处理成 {0: ‘a’, 1: ‘b’}，所以如果合并的两个数组的话，则后面的数组项会替换前面的数组项，因为它们具有相同的属性名：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'aa'</span>, <span class="string">'bb'</span>], [<span class="string">'e'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// ["e", "bb", "c"]</span></span><br></pre></td></tr></table></figure>
<p>这显然是不可取的。上面的做法只是一个演示，如果要合并多个数组，我们可以用数组自身的方法 <code>concat</code>。</p>
<p>如果该方法的参数是一些特殊值，比如 <code>undefined</code> 、 <code>null</code>，那它会直接报错，因为这些特殊值无法转换为对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(<span class="literal">undefined</span>)); <span class="comment">// 报错 Cannot convert undefined or null to object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(<span class="literal">null</span>)); <span class="comment">// 报错 Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure>
<p>前面的定义中说了，<code>Object.assign</code> 只是浅拷贝，它只能拷贝 源对象自身的并且可枚举的属性，而 继承属性和不可枚举属性是不能拷贝的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.prototype.age = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> person(<span class="string">'yix'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1); <span class="comment">// &#123;name: "yix"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.age); <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(&#123;&#125;, person1)); <span class="comment">// &#123;name: "yix"&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面中的 age 属性是对象原型上的，这是属于原型继承属性，因此不能被拷贝到源对象上。</p>
<h2 id="三、原型方法扩展"><a href="#三、原型方法扩展" class="headerlink" title="三、原型方法扩展"></a>三、原型方法扩展</h2><p>一直以来，原型(prototype)都是JS中面向对象编程最重要的一部分。通过它，我们可以在对象之间继承各种属性和方法。</p>
<h3 id="3-1-Object-getPrototypeOf"><a href="#3-1-Object-getPrototypeOf" class="headerlink" title="3.1 Object.getPrototypeOf()"></a>3.1 Object.getPrototypeOf()</h3><p>该方法最早出现在 ES5 中，它的作用是获取对象的prototype：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1)); <span class="comment">// &#123;name: "yix"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) === person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-Object-setPrototypeOf"><a href="#3-2-Object-setPrototypeOf" class="headerlink" title="3.2 Object.setPrototypeOf()"></a>3.2 Object.setPrototypeOf()</h3><p>虽然通过上面的方法很轻松的就获取到对象的prototype，但却没有一种符合规范的方法可以改变对象的prototype（实际上可以用 <code>__proto__</code> 进行 Polyfill），也就是说只能读取，不能设置。而 ES6 提供了 <code>Object.setPrototypeOf</code> 方法解决了这个问题，该方法的语法如下，其中 <code>obj</code> 为被设置原型的对象，而 <code>prototype</code> 为设置的原型： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, prototype)</span><br></pre></td></tr></table></figure>
<p>来看个实际例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">'yix'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">'abc'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newPerson = <span class="built_in">Object</span>.create(person1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newPerson.name); <span class="comment">// 'yix'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(newPerson) === person1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 prototype</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(newPerson, person2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(newPerson) === person1); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(newPerson.name); <span class="comment">// 'abc'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(newPerson) === person2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>newPerson</code> 一开始继承的是 <code>person1</code> 对象，所以对应的属性和原型都是 <code>person1</code> 对象。而后面通过 <code>setPrototypeOf</code> 改变了 <code>newPerson</code> 的原型，于是它所有的内容都来自 <code>person2</code> 对象。其实读取和设置原型，都是基于js内部的 <code>[[Prototype]]</code> 对象。</p>
<h3 id="3-3-super"><a href="#3-3-super" class="headerlink" title="3.3 super"></a>3.3 super</h3><p>由于对象中存在多层继承，有时候可能无法找到对象的原型对象。而 ES6 中引入 <code>super</code> ，它是一个指向当前对象原型的指针，这样，我们可以很轻松的访问原型对象。</p>
<p>还是用例子来说明下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'yix'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).showName() + <span class="string">' abc'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person2, person1);</span><br><span class="line"><span class="built_in">console</span>.log(person2.showName()); <span class="comment">// 'yix abc'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person3 = <span class="built_in">Object</span>.create(person2);</span><br><span class="line"><span class="keyword">var</span> person4 = <span class="built_in">Object</span>.create(person3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person3.showName()); <span class="comment">// 'yix abc abc'</span></span><br><span class="line"><span class="built_in">console</span>.log(person4.showName()); <span class="comment">// 'yix abc abc abc'</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，对象 <code>person3</code> 的 <code>super</code> 为 <code>person2</code>，而 <code>person4</code> 的 <code>super</code> 为 <code>person3</code> 。</p>

  </div>

</div>

  <div class="footer">
    <a href="http://www.yi-jy.com">前端技术空间--易建勇</a> /
    <a href="http://www.beianbeian.com/search/yi-jy.com">Copyright © 2012-2018</a> /
    <a href="https://github.com/joy-yi0905/hexo-theme-record">Record</a> /
    <a href="http://yi-jy.com/atom.xml">Rss</a>
  </div>

</div>

</body>


    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7d5550c80ba3b42cfa5323fc0e92699f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


</html>